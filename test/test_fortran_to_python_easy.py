import os
import unittest

import fortran_to_python_easy as f2pe


class TestFortranToPythonEasy(unittest.TestCase):
    def setUp(self):
        self.filename = os.path.join(os.pardir, 'pyslicot', 'SB02MT.f')

    def test_split_symbols(self):
        fortran_line = '      SUBROUTINE SB02MT (  JOBG, JOBL, FACT, UPLO, N, M, A, LDA, B, LDB,'
        split_symbols_list = f2pe.split_symbols(fortran_line)
        expected_split_symbols_list = ['SUBROUTINE', 'SB02MT', '(', 'JOBG', 'JOBL', 'FACT', 'UPLO', 'N', 'M', 'A',
                                       'LDA', 'B', 'LDB']
        self.assertSequenceEqual(expected_split_symbols_list, split_symbols_list)

    def test_fortran_filename_to_python_filename(self):
        fortran_filename = 'SB02MT.f'
        result = f2pe.fortran_filename_to_python_filename(fortran_filename)
        expected = 'sb02mt.py'
        self.assertEqual(expected, result)

    def test_replace_logical_operators(self):
        fortran_code, expected = (
        '      SUBROUTINE SB02MT( JOBG, JOBL, FACT, UPLO, N, M, A, LDA, B, LDB,\n     $                   Q, LDQ, R, LDR, L, LDL, IPIV, OUFACT, G, LDG,\n     $                   IWORK, DWORK, LDWORK, INFO )\nC\nC     SLICOT RELEASE 5.0.\nC\nC     Copyright (c) 2002-2009 NICONET e.V.\nC\nC     This program is free software: you can redistribute it and/or\nC     modify it under the terms of the GNU General Public License as\nC     published by the Free Software Foundation, either version 2 of\nC     the License, or (at your option) any later version.\nC\nC     This program is distributed in the hope that it will be useful,\nC     but WITHOUT ANY WARRANTY; without even the implied warranty of\nC     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nC     GNU General Public License for more details.\nC\nC     You should have received a copy of the GNU General Public License\nC     along with this program.  If not, see\nC     <http://www.gnu.org/licenses/>.\nC\nC     PURPOSE\nC\nC     To compute the following matrices\nC\nC                -1\nC         G = B*R  *B\',\nC\nC         -          -1\nC         A = A - B*R  *L\',\nC\nC         -          -1\nC         Q = Q - L*R  *L\',\nC\nC     where A, B, Q, R, L, and G are N-by-N, N-by-M, N-by-N, M-by-M,\nC     N-by-M, and N-by-N matrices, respectively, with Q, R and G\nC     symmetric matrices.\nC\nC     When R is well-conditioned with respect to inversion, standard\nC     algorithms for solving linear-quadratic optimization problems will\nC     then also solve optimization problems with coupling weighting\nC     matrix L. Moreover, a gain in efficiency is possible using matrix\nC     G in the deflating subspace algorithms (see SLICOT Library routine\nC     SB02OD).\nC\nC     ARGUMENTS\nC\nC     Mode Parameters\nC\nC     JOBG    CHARACTER*1\nC             Specifies whether or not the matrix G is to be computed,\nC             as follows:\nC             = \'G\':  Compute G;\nC             = \'N\':  Do not compute G.\nC\nC     JOBL    CHARACTER*1\nC             Specifies whether or not the matrix L is zero, as follows:\nC             = \'Z\':  L is zero;\nC             = \'N\':  L is nonzero.\nC\nC     FACT    CHARACTER*1\nC             Specifies how the matrix R is given (factored or not), as\nC             follows:\nC             = \'N\':  Array R contains the matrix R;\nC             = \'C\':  Array R contains the Cholesky factor of R;\nC             = \'U\':  Array R contains the symmetric indefinite UdU\' or\nC                     LdL\' factorization of R.\nC\nC     UPLO    CHARACTER*1\nC             Specifies which triangle of the matrices R and Q (if\nC             JOBL = \'N\') is stored, as follows:\nC             = \'U\':  Upper triangle is stored;\nC             = \'L\':  Lower triangle is stored.\nC\nC     Input/Output Parameters\nC\nC     N       (input) INTEGER\nC             The order of the matrices A, Q, and G, and the number of\nC             rows of the matrices B and L.  N >= 0.\nC\nC     M       (input) INTEGER\nC             The order of the matrix R, and the number of columns of\nC             the matrices B and L.  M >= 0.\nC\nC     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)\nC             On entry, if JOBL = \'N\', the leading N-by-N part of this\nC             array must contain the matrix A.\nC             On exit, if JOBL = \'N\', and INFO = 0, the leading N-by-N\nC                                                    -          -1\nC             part of this array contains the matrix A = A - B*R  L\'.\nC             If JOBL = \'Z\', this array is not referenced.\nC\nC     LDA     INTEGER\nC             The leading dimension of array A.\nC             LDA >= MAX(1,N) if JOBL = \'N\';\nC             LDA >= 1        if JOBL = \'Z\'.\nC\nC     B       (input/output) DOUBLE PRECISION array, dimension (LDB,M)\nC             On entry, the leading N-by-M part of this array must\nC             contain the matrix B.\nC             On exit, if OUFACT = 1, and INFO = 0, the leading N-by-M\nC                                                             -1\nC             part of this array contains the matrix B*chol(R)  .\nC             On exit, B is unchanged if OUFACT = 2 (hence also when\nC             FACT = \'U\').\nC\nC     LDB     INTEGER\nC             The leading dimension of array B.  LDB >= MAX(1,N).\nC\nC     Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)\nC             On entry, if JOBL = \'N\', the leading N-by-N upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array must contain the upper\nC             triangular part or lower triangular part, respectively, of\nC             the symmetric matrix Q. The stricly lower triangular part\nC             (if UPLO = \'U\') or stricly upper triangular part (if\nC             UPLO = \'L\') is not referenced.\nC             On exit, if JOBL = \'N\' and INFO = 0, the leading N-by-N\nC             upper triangular part (if UPLO = \'U\') or lower triangular\nC             part (if UPLO = \'L\') of this array contains the upper\nC             triangular part or lower triangular part, respectively, of\nC                                  -          -1\nC             the symmetric matrix Q = Q - L*R  *L\'.\nC             If JOBL = \'Z\', this array is not referenced.\nC\nC     LDQ     INTEGER\nC             The leading dimension of array Q.\nC             LDQ >= MAX(1,N) if JOBL = \'N\';\nC             LDQ >= 1        if JOBL = \'Z\'.\nC\nC     R       (input/output) DOUBLE PRECISION array, dimension (LDR,M)\nC             On entry, if FACT = \'N\', the leading M-by-M upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array must contain the upper\nC             triangular part or lower triangular part, respectively,\nC             of the symmetric input weighting matrix R.\nC             On entry, if FACT = \'C\', the leading M-by-M upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array must contain the Cholesky\nC             factor of the positive definite input weighting matrix R\nC             (as produced by LAPACK routine DPOTRF).\nC             On entry, if FACT = \'U\', the leading M-by-M upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array must contain the factors of\nC             the UdU\' or LdL\' factorization, respectively, of the\nC             symmetric indefinite input weighting matrix R (as produced\nC             by LAPACK routine DSYTRF).\nC             If FACT = \'N\', the stricly lower triangular part (if UPLO\nC             = \'U\') or stricly upper triangular part (if UPLO = \'L\') of\nC             this array is used as workspace.\nC             On exit, if OUFACT = 1, and INFO = 0 (or INFO = M+1),\nC             the leading M-by-M upper triangular part (if UPLO = \'U\')\nC             or lower triangular part (if UPLO = \'L\') of this array\nC             contains the Cholesky factor of the given input weighting\nC             matrix.\nC             On exit, if OUFACT = 2, and INFO = 0 (or INFO = M+1),\nC             the leading M-by-M upper triangular part (if UPLO = \'U\')\nC             or lower triangular part (if UPLO = \'L\') of this array\nC             contains the factors of the UdU\' or LdL\' factorization,\nC             respectively, of the given input weighting matrix.\nC             On exit R is unchanged if FACT = \'C\' or \'U\'.\nC\nC     LDR     INTEGER\nC             The leading dimension of array R.  LDR >= MAX(1,M).\nC\nC     L       (input/output) DOUBLE PRECISION array, dimension (LDL,M)\nC             On entry, if JOBL = \'N\', the leading N-by-M part of this\nC             array must contain the matrix L.\nC             On exit, if JOBL = \'N\', OUFACT = 1, and INFO = 0, the\nC             leading N-by-M part of this array contains the matrix\nC                      -1\nC             L*chol(R)  .\nC             On exit, L is unchanged if OUFACT = 2 (hence also when\nC             FACT = \'U\').\nC             L is not referenced if JOBL = \'Z\'.\nC\nC     LDL     INTEGER\nC             The leading dimension of array L.\nC             LDL >= MAX(1,N) if JOBL = \'N\';\nC             LDL >= 1        if JOBL = \'Z\'.\nC\nC     IPIV    (input/output) INTEGER array, dimension (M)\nC             On entry, if FACT = \'U\', this array must contain details\nC             of the interchanges performed and the block structure of\nC             the d factor in the UdU\' or LdL\' factorization of matrix R\nC             (as produced by LAPACK routine DSYTRF).\nC             On exit, if OUFACT = 2, this array contains details of\nC             the interchanges performed and the block structure of the\nC             d factor in the UdU\' or LdL\' factorization of matrix R,\nC             as produced by LAPACK routine DSYTRF.\nC             This array is not referenced if FACT = \'C\'.\nC\nC     OUFACT  (output) INTEGER\nC             Information about the factorization finally used.\nC             OUFACT = 1:  Cholesky factorization of R has been used;\nC             OUFACT = 2:  UdU\' (if UPLO = \'U\') or LdL\' (if UPLO = \'L\')\nC                          factorization of R has been used.\nC\nC     G       (output) DOUBLE PRECISION array, dimension (LDG,N)\nC             If JOBG = \'G\', and INFO = 0, the leading N-by-N upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array contains the upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC                                                                 -1\nC             (if UPLO = \'L\'), respectively, of the matrix G = B*R  B\'.\nC             If JOBG = \'N\', this array is not referenced.\nC\nC     LDG     INTEGER\nC             The leading dimension of array G.\nC             LDG >= MAX(1,N) if JOBG = \'G\',\nC             LDG >= 1        if JOBG = \'N\'.\nC\nC     Workspace\nC\nC     IWORK   INTEGER array, dimension (M)\nC\nC     DWORK   DOUBLE PRECISION array, dimension (LDWORK)\nC             On exit, if INFO = 0, DWORK(1) returns the optimal value\nC             of LDWORK; if FACT = \'N\', DWORK(2) contains the reciprocal\nC             condition number of the given matrix R.\nC\nC     LDWORK  INTEGER\nC             The length of the array DWORK.\nC             LDWORK >= 1              if FACT = \'C\';\nC             LDWORK >= MAX(2,3*M,N*M) if FACT = \'N\';\nC             LDWORK >= MAX(1,N*M)     if FACT = \'U\'.\nC             For optimum performance LDWORK should be larger than 3*M,\nC             if FACT = \'N\'.\nC             The N*M workspace is not needed for FACT = \'N\', if matrix\nC             R is positive definite.\nC\nC     Error Indicator\nC\nC     INFO    INTEGER\nC             = 0:  successful exit;\nC             < 0:  if INFO = -i, the i-th argument had an illegal\nC                   value;\nC             = i:  if the i-th element (1 <= i <= M) of the d factor is\nC                   exactly zero; the UdU\' (or LdL\') factorization has\nC                   been completed, but the block diagonal matrix d is\nC                   exactly singular;\nC             = M+1:  if the matrix R is numerically singular.\nC\nC     METHOD\nC                            -     -\nC     The matrices G, and/or A and Q are evaluated using the given or\nC     computed symmetric factorization of R.\nC\nC     NUMERICAL ASPECTS\nC\nC     The routine should not be used when R is ill-conditioned.\nC\nC     CONTRIBUTOR\nC\nC     Release 3.0: V. Sima, Katholieke Univ. Leuven, Belgium, Sep. 1997.\nC\nC     REVISIONS\nC\nC     -\nC\nC     KEYWORDS\nC\nC     Algebraic Riccati equation, closed loop system, continuous-time\nC     system, discrete-time system, optimal regulator, Schur form.\nC\nC     ******************************************************************\n"""\nC\nC     .. Parameters ..\n      DOUBLE PRECISION  ZERO, ONE\n      PARAMETER         ( ZERO = 0.0D0, ONE = 1.0D0 )\nC     .. Scalar Arguments ..\n      CHARACTER         FACT, JOBG, JOBL, UPLO\n      INTEGER           INFO, LDA, LDB, LDG, LDL, LDQ, LDR, LDWORK, M,\n     $                  N, OUFACT\nC     .. Array Arguments ..\n      INTEGER           IPIV(*), IWORK(*)\n      DOUBLE PRECISION  A(LDA,*), B(LDB,*), DWORK(*), G(LDG,*),\n     $                  L(LDL,*), Q(LDQ,*), R(LDR,*)\nC     .. Local Scalars ..\n      LOGICAL           LFACTA, LFACTC, LFACTU, LJOBG, LJOBL, LUPLOU\n      CHARACTER         TRANS\n      INTEGER           I, J, WRKOPT\n      DOUBLE PRECISION  EPS, RCOND, RNORM\nC     .. External Functions ..\n      LOGICAL           LSAME\n      DOUBLE PRECISION  DLAMCH, DLANSY\n      EXTERNAL          DLAMCH, DLANSY, LSAME\nC     .. External Subroutines ..\n      EXTERNAL          DCOPY, DGEMM, DGEMV, DPOCON, DPOTRF, DSYCON,\n     $                  DSYRK, DSYTRF, DSYTRS, DTRSM, XERBLA\nC     .. Intrinsic Functions ..\n      INTRINSIC         INT, MAX\nC     .. Executable Statements ..\nC\n      INFO   = 0\n      LJOBG  = LSAME( JOBG, \'G\' )\n      LJOBL  = LSAME( JOBL, \'N\' )\n      LFACTC = LSAME( FACT, \'C\' )\n      LFACTU = LSAME( FACT, \'U\' )\n      LUPLOU = LSAME( UPLO, \'U\' )\n      LFACTA = LFACTC.OR.LFACTU\nC\nC     Test the input scalar arguments.\nC\n      IF( .NOT.LJOBG .AND. .NOT.LSAME( JOBG, \'N\' ) ) THEN\n         INFO = -1\n      ELSE IF( .NOT.LJOBL .AND. .NOT.LSAME( JOBL, \'Z\' ) ) THEN\n         INFO = -2\n      ELSE IF( .NOT.LFACTA .AND. .NOT.LSAME( FACT, \'N\' ) ) THEN\n         INFO = -3\n      ELSE IF( .NOT.LUPLOU .AND. .NOT.LSAME( UPLO, \'L\' ) ) THEN\n         INFO = -4\n      ELSE IF( N.LT.0 ) THEN\n         INFO = -5\n      ELSE IF( M.LT.0 ) THEN\n         INFO = -6\n      ELSE IF( ( LDA.LT.1 ) .OR. ( LJOBL .AND. LDA.LT.N ) ) THEN\n         INFO = -8\n      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN\n         INFO = -10\n      ELSE IF( ( LDQ.LT.1 ) .OR. ( LJOBL .AND. LDQ.LT.N ) ) THEN\n         INFO = -12\n      ELSE IF( LDR.LT.MAX( 1, M ) ) THEN\n         INFO = -14\n      ELSE IF( ( LDL.LT.1 ) .OR. ( LJOBL .AND. LDL.LT.N ) ) THEN\n         INFO = -16\n      ELSE IF( ( LDG.LT.1 ) .OR. ( LJOBG .AND. LDG.LT.N ) ) THEN\n         INFO = -20\n      ELSE IF( ( LFACTC .AND. LDWORK.LT.1 ) .OR.\n     $         ( LFACTU .AND. LDWORK.LT.MAX( 1, N*M ) ) .OR.\n     $    ( .NOT.LFACTA .AND. LDWORK.LT.MAX( 2, N*M, 3*M ) ) ) THEN\n         INFO = -23\n      END IF\nC\n      IF ( INFO.NE.0 ) THEN\nC\nC        Error return.\nC\n         CALL XERBLA( \'sb02mt\', -INFO )\n         RETURN\n      END IF\nC\n      IF ( LFACTC ) THEN\n         OUFACT = 1\n      ELSE IF ( LFACTU ) THEN\n         OUFACT = 2\n      END IF\nC\nC     Quick return if possible.\nC\n      IF ( N.EQ.0 .OR. M.EQ.0 .OR. .NOT.( LJOBL.OR.LJOBG ) ) THEN\n        DWORK(1) = ONE\n        IF ( .NOT.LFACTA ) DWORK(2) = ONE\n        RETURN\n      END IF\nC\nC     (Note: Comments in the code beginning "Workspace:" describe the\nC     minimal amount of workspace needed at that point in the code,\nC     as well as the preferred amount for good performance.\nC     NB refers to the optimal block size for the immediately\nC     following subroutine, as returned by ILAENV.)\nC\n      WRKOPT = 1\nC\nC     Set relative machine precision.\nC\n      EPS = DLAMCH( \'Epsilon\' )\nC\n      IF ( .NOT.LFACTA ) THEN\nC\nC        Compute the norm of the matrix R, which is not factored.\nC        Then save the given triangle of R in the other strict triangle\nC        and the diagonal in the workspace, and try Cholesky\nC        factorization.\nC        Workspace: need M.\nC\n         RNORM = DLANSY( \'1-norm\', UPLO, M, R, LDR, DWORK )\n         CALL DCOPY( M, R, LDR+1, DWORK, 1 )\n         IF( LUPLOU ) THEN\nC\n            DO 20 J = 2, M\n               CALL DCOPY( J-1, R(1,J), 1, R(J,1), LDR )\n   20       CONTINUE\nC\n         ELSE\nC\n            DO 40 J = 2, M\n               CALL DCOPY( J-1, R(J,1), LDR, R(1,J), 1 )\n   40       CONTINUE\nC\n         END IF\n         CALL DPOTRF( UPLO, M, R, LDR, INFO )\n         IF( INFO.EQ.0 ) THEN\nC\nC           Compute the reciprocal of the condition number of R.\nC           Workspace: need 3*M.\nC\n            CALL DPOCON( UPLO, M, R, LDR, RNORM, RCOND, DWORK, IWORK,\n     $                   INFO )\nC\nC           Return if the matrix is singular to working precision.\nC\n            OUFACT = 1\n            DWORK(2) = RCOND\n            IF( RCOND.LT.EPS ) THEN\n               INFO = M + 1\n               RETURN\n            END IF\n            WRKOPT = MAX( WRKOPT, 3*M )\n         ELSE\nC\nC           Use UdU\' or LdL\' factorization, first restoring the saved\nC           triangle.\nC\n            CALL DCOPY( M, DWORK, 1, R, LDR+1 )\n            IF( LUPLOU ) THEN\nC\n               DO 60 J = 2, M\n                  CALL DCOPY( J-1, R(J,1), LDR, R(1,J), 1 )\n   60          CONTINUE\nC\n            ELSE\nC\n               DO 80 J = 2, M\n                  CALL DCOPY( J-1, R(1,J), 1, R(J,1), LDR )\n   80          CONTINUE\nC\n            END IF\nC\nC           Compute the UdU\' or LdL\' factorization.\nC           Workspace: need   1,\nC                      prefer M*NB.\nC\n            CALL DSYTRF( UPLO, M, R, LDR, IPIV, DWORK, LDWORK, INFO )\n            OUFACT = 2\n            IF( INFO.GT.0 ) THEN\n               DWORK(2) = ONE\n               RETURN\n            END IF\n            WRKOPT = MAX( WRKOPT, INT( DWORK(1) ) )\nC\nC           Compute the reciprocal of the condition number of R.\nC           Workspace: need 2*M.\nC\n            CALL DSYCON( UPLO, M, R, LDR, IPIV, RNORM, RCOND, DWORK,\n     $                   IWORK, INFO )\nC\nC           Return if the matrix is singular to working precision.\nC\n            DWORK(2) = RCOND\n            IF( RCOND.LT.EPS ) THEN\n               INFO = M + 1\n               RETURN\n            END IF\n         END IF\n      END IF\nC\n      IF (OUFACT.EQ.1 ) THEN\nC\nC        Solve positive definite linear system(s).\nC\n         IF ( LUPLOU ) THEN\n            TRANS = \'N\'\n         ELSE\n            TRANS = \'T\'\n         END IF\nC\nC        Solve the system X*U = B, overwriting B with X.\nC\n         CALL DTRSM( \'Right\', UPLO, TRANS, \'Non-unit\', N, M,\n     $               ONE, R, LDR, B, LDB )\nC\n         IF ( LJOBG ) THEN\nC                                      -1\nC           Compute the matrix  G = B*R  *B\', multiplying X*X\' in G.\nC\n            CALL DSYRK( UPLO, \'No transpose\', N, M, ONE, B, LDB, ZERO,\n     $                  G, LDG )\n         END IF\nC\n         IF( LJOBL ) THEN\nC\nC           Update matrices A and Q.\nC\nC           Solve the system Y*U = L, overwriting L with Y.\nC\n            CALL DTRSM( \'Right\', UPLO, TRANS, \'Non-unit\', N, M,\n     $                  ONE, R, LDR, L, LDL )\nC\nC           Compute A <- A - X*Y\'.\nC\n            CALL DGEMM( \'No transpose\', \'Transpose\', N, N, M, -ONE, B,\n     $                  LDB, L, LDL, ONE, A, LDA )\nC\nC           Compute Q <- Q - Y*Y\'.\nC\n            CALL DSYRK( UPLO, \'No transpose\', N, M, -ONE, L, LDL, ONE,\n     $                  Q, LDQ )\n         END IF\n      ELSE\nC\nC        Solve indefinite linear system(s).\nC\nC        Solve the system UdU\'*X = B\' (or LdL\'*X = B\').\nC        Workspace: need N*M.\nC\n         DO 100 J = 1, M\n            CALL DCOPY( N, B(1,J), 1, DWORK(J), M )\n  100    CONTINUE\nC\n         CALL DSYTRS( UPLO, M, N, R, LDR, IPIV, DWORK, M, INFO )\nC\n         IF ( LJOBG ) THEN\nC                                                    -1\nC           Compute a triangle of the matrix  G = B*R  *B\' = B*X.\nC\n            IF ( LUPLOU ) THEN\n               I = 1\nC\n               DO 120 J = 1, N\n                  CALL DGEMV( \'No transpose\', J, M, ONE, B, LDB,\n     $                        DWORK(I), 1, ZERO, G(1,J), 1 )\n                  I = I + M\n  120          CONTINUE\nC\n            ELSE\nC\n               DO 140 J = 1, N\n                  CALL DGEMV( \'Transpose\', M, J, ONE, DWORK, M, B(J,1),\n     $                        LDB, ZERO, G(J,1), LDG )\n  140          CONTINUE\nC\n            END IF\n         END IF\nC\n         IF( LJOBL ) THEN\nC\nC           Update matrices A and Q.\nC\nC           Solve the system UdU\'*Y = L\' (or LdL\'*Y = L\').\nC\n            DO 160 J = 1, M\n               CALL DCOPY( N, L(1,J), 1, DWORK(J), M )\n  160       CONTINUE\nC\n            CALL DSYTRS( UPLO, M, N, R, LDR, IPIV, DWORK, M, INFO )\nC\nC           A <- A - B*Y.\nC\n            CALL DGEMM( \'No transpose\', \'No transpose\', N, N, M, -ONE,\n     $                  B, LDB, DWORK, M, ONE, A, LDA )\nC                                            -          -1\nC           Compute a triangle of the matrix Q = Q - L*R  *L\' = Q - L*Y.\nC\n            IF ( LUPLOU ) THEN\n               I = 1\nC\n               DO 180 J = 1, N\n                  CALL DGEMV( \'No transpose\', J, M, -ONE, L, LDL,\n     $                        DWORK(I), 1, ONE, Q(1,J), 1 )\n                  I = I + M\n  180          CONTINUE\nC\n            ELSE\nC\n               DO 200 J = 1, N\n                  CALL DGEMV( \'Transpose\', M, J, -ONE, DWORK, M, L(J,1),\n     $                        LDL, ONE, Q(J,1), LDQ )\n  200          CONTINUE\nC\n            END IF\n         END IF\n      END IF\nC\n      DWORK(1) = WRKOPT\n      IF ( .NOT.LFACTA ) DWORK(2) = RCOND\nC\nC *** Last line of SB02MT ***\n      RETURN\n      END\n',
        '      SUBROUTINE SB02MT( JOBG, JOBL, FACT, UPLO, N, M, A, LDA, B, LDB,\n     $                   Q, LDQ, R, LDR, L, LDL, IPIV, OUFACT, G, LDG,\n     $                   IWORK, DWORK, LDWORK, INFO )\nC\nC     SLICOT RELEASE 5.0.\nC\nC     Copyright (c) 2002-2009 NICONET e.V.\nC\nC     This program is free software: you can redistribute it and/or\nC     modify it under the terms of the GNU General Public License as\nC     published by the Free Software Foundation, either version 2 of\nC     the License, or (at your option) any later version.\nC\nC     This program is distributed in the hope that it will be useful,\nC     but WITHOUT ANY WARRANTY; without even the implied warranty of\nC     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nC     GNU General Public License for more details.\nC\nC     You should have received a copy of the GNU General Public License\nC     along with this program.  If not, see\nC     <http://www.gnu.org/licenses/>.\nC\nC     PURPOSE\nC\nC     To compute the following matrices\nC\nC                -1\nC         G = B*R  *B\',\nC\nC         -          -1\nC         A = A - B*R  *L\',\nC\nC         -          -1\nC         Q = Q - L*R  *L\',\nC\nC     where A, B, Q, R, L, and G are N-by-N, N-by-M, N-by-N, M-by-M,\nC     N-by-M, and N-by-N matrices, respectively, with Q, R and G\nC     symmetric matrices.\nC\nC     When R is well-conditioned with respect to inversion, standard\nC     algorithms for solving linear-quadratic optimization problems will\nC     then also solve optimization problems with coupling weighting\nC     matrix L. Moreover, a gain in efficiency is possible using matrix\nC     G in the deflating subspace algorithms (see SLICOT Library routine\nC     SB02OD).\nC\nC     ARGUMENTS\nC\nC     Mode Parameters\nC\nC     JOBG    CHARACTER*1\nC             Specifies whether or not the matrix G is to be computed,\nC             as follows:\nC             = \'G\':  Compute G;\nC             = \'N\':  Do not compute G.\nC\nC     JOBL    CHARACTER*1\nC             Specifies whether or not the matrix L is zero, as follows:\nC             = \'Z\':  L is zero;\nC             = \'N\':  L is nonzero.\nC\nC     FACT    CHARACTER*1\nC             Specifies how the matrix R is given (factored or not), as\nC             follows:\nC             = \'N\':  Array R contains the matrix R;\nC             = \'C\':  Array R contains the Cholesky factor of R;\nC             = \'U\':  Array R contains the symmetric indefinite UdU\' or\nC                     LdL\' factorization of R.\nC\nC     UPLO    CHARACTER*1\nC             Specifies which triangle of the matrices R and Q (if\nC             JOBL = \'N\') is stored, as follows:\nC             = \'U\':  Upper triangle is stored;\nC             = \'L\':  Lower triangle is stored.\nC\nC     Input/Output Parameters\nC\nC     N       (input) INTEGER\nC             The order of the matrices A, Q, and G, and the number of\nC             rows of the matrices B and L.  N >= 0.\nC\nC     M       (input) INTEGER\nC             The order of the matrix R, and the number of columns of\nC             the matrices B and L.  M >= 0.\nC\nC     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)\nC             On entry, if JOBL = \'N\', the leading N-by-N part of this\nC             array must contain the matrix A.\nC             On exit, if JOBL = \'N\', and INFO = 0, the leading N-by-N\nC                                                    -          -1\nC             part of this array contains the matrix A = A - B*R  L\'.\nC             If JOBL = \'Z\', this array is not referenced.\nC\nC     LDA     INTEGER\nC             The leading dimension of array A.\nC             LDA >= MAX(1,N) if JOBL = \'N\';\nC             LDA >= 1        if JOBL = \'Z\'.\nC\nC     B       (input/output) DOUBLE PRECISION array, dimension (LDB,M)\nC             On entry, the leading N-by-M part of this array must\nC             contain the matrix B.\nC             On exit, if OUFACT = 1, and INFO = 0, the leading N-by-M\nC                                                             -1\nC             part of this array contains the matrix B*chol(R)  .\nC             On exit, B is unchanged if OUFACT = 2 (hence also when\nC             FACT = \'U\').\nC\nC     LDB     INTEGER\nC             The leading dimension of array B.  LDB >= MAX(1,N).\nC\nC     Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)\nC             On entry, if JOBL = \'N\', the leading N-by-N upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array must contain the upper\nC             triangular part or lower triangular part, respectively, of\nC             the symmetric matrix Q. The stricly lower triangular part\nC             (if UPLO = \'U\') or stricly upper triangular part (if\nC             UPLO = \'L\') is not referenced.\nC             On exit, if JOBL = \'N\' and INFO = 0, the leading N-by-N\nC             upper triangular part (if UPLO = \'U\') or lower triangular\nC             part (if UPLO = \'L\') of this array contains the upper\nC             triangular part or lower triangular part, respectively, of\nC                                  -          -1\nC             the symmetric matrix Q = Q - L*R  *L\'.\nC             If JOBL = \'Z\', this array is not referenced.\nC\nC     LDQ     INTEGER\nC             The leading dimension of array Q.\nC             LDQ >= MAX(1,N) if JOBL = \'N\';\nC             LDQ >= 1        if JOBL = \'Z\'.\nC\nC     R       (input/output) DOUBLE PRECISION array, dimension (LDR,M)\nC             On entry, if FACT = \'N\', the leading M-by-M upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array must contain the upper\nC             triangular part or lower triangular part, respectively,\nC             of the symmetric input weighting matrix R.\nC             On entry, if FACT = \'C\', the leading M-by-M upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array must contain the Cholesky\nC             factor of the positive definite input weighting matrix R\nC             (as produced by LAPACK routine DPOTRF).\nC             On entry, if FACT = \'U\', the leading M-by-M upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array must contain the factors of\nC             the UdU\' or LdL\' factorization, respectively, of the\nC             symmetric indefinite input weighting matrix R (as produced\nC             by LAPACK routine DSYTRF).\nC             If FACT = \'N\', the stricly lower triangular part (if UPLO\nC             = \'U\') or stricly upper triangular part (if UPLO = \'L\') of\nC             this array is used as workspace.\nC             On exit, if OUFACT = 1, and INFO = 0 (or INFO = M+1),\nC             the leading M-by-M upper triangular part (if UPLO = \'U\')\nC             or lower triangular part (if UPLO = \'L\') of this array\nC             contains the Cholesky factor of the given input weighting\nC             matrix.\nC             On exit, if OUFACT = 2, and INFO = 0 (or INFO = M+1),\nC             the leading M-by-M upper triangular part (if UPLO = \'U\')\nC             or lower triangular part (if UPLO = \'L\') of this array\nC             contains the factors of the UdU\' or LdL\' factorization,\nC             respectively, of the given input weighting matrix.\nC             On exit R is unchanged if FACT = \'C\' or \'U\'.\nC\nC     LDR     INTEGER\nC             The leading dimension of array R.  LDR >= MAX(1,M).\nC\nC     L       (input/output) DOUBLE PRECISION array, dimension (LDL,M)\nC             On entry, if JOBL = \'N\', the leading N-by-M part of this\nC             array must contain the matrix L.\nC             On exit, if JOBL = \'N\', OUFACT = 1, and INFO = 0, the\nC             leading N-by-M part of this array contains the matrix\nC                      -1\nC             L*chol(R)  .\nC             On exit, L is unchanged if OUFACT = 2 (hence also when\nC             FACT = \'U\').\nC             L is not referenced if JOBL = \'Z\'.\nC\nC     LDL     INTEGER\nC             The leading dimension of array L.\nC             LDL >= MAX(1,N) if JOBL = \'N\';\nC             LDL >= 1        if JOBL = \'Z\'.\nC\nC     IPIV    (input/output) INTEGER array, dimension (M)\nC             On entry, if FACT = \'U\', this array must contain details\nC             of the interchanges performed and the block structure of\nC             the d factor in the UdU\' or LdL\' factorization of matrix R\nC             (as produced by LAPACK routine DSYTRF).\nC             On exit, if OUFACT = 2, this array contains details of\nC             the interchanges performed and the block structure of the\nC             d factor in the UdU\' or LdL\' factorization of matrix R,\nC             as produced by LAPACK routine DSYTRF.\nC             This array is not referenced if FACT = \'C\'.\nC\nC     OUFACT  (output) INTEGER\nC             Information about the factorization finally used.\nC             OUFACT = 1:  Cholesky factorization of R has been used;\nC             OUFACT = 2:  UdU\' (if UPLO = \'U\') or LdL\' (if UPLO = \'L\')\nC                          factorization of R has been used.\nC\nC     G       (output) DOUBLE PRECISION array, dimension (LDG,N)\nC             If JOBG = \'G\', and INFO = 0, the leading N-by-N upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC             (if UPLO = \'L\') of this array contains the upper\nC             triangular part (if UPLO = \'U\') or lower triangular part\nC                                                                 -1\nC             (if UPLO = \'L\'), respectively, of the matrix G = B*R  B\'.\nC             If JOBG = \'N\', this array is not referenced.\nC\nC     LDG     INTEGER\nC             The leading dimension of array G.\nC             LDG >= MAX(1,N) if JOBG = \'G\',\nC             LDG >= 1        if JOBG = \'N\'.\nC\nC     Workspace\nC\nC     IWORK   INTEGER array, dimension (M)\nC\nC     DWORK   DOUBLE PRECISION array, dimension (LDWORK)\nC             On exit, if INFO = 0, DWORK(1) returns the optimal value\nC             of LDWORK; if FACT = \'N\', DWORK(2) contains the reciprocal\nC             condition number of the given matrix R.\nC\nC     LDWORK  INTEGER\nC             The length of the array DWORK.\nC             LDWORK >= 1              if FACT = \'C\';\nC             LDWORK >= MAX(2,3*M,N*M) if FACT = \'N\';\nC             LDWORK >= MAX(1,N*M)     if FACT = \'U\'.\nC             For optimum performance LDWORK should be larger than 3*M,\nC             if FACT = \'N\'.\nC             The N*M workspace is not needed for FACT = \'N\', if matrix\nC             R is positive definite.\nC\nC     Error Indicator\nC\nC     INFO    INTEGER\nC             = 0:  successful exit;\nC             < 0:  if INFO = -i, the i-th argument had an illegal\nC                   value;\nC             = i:  if the i-th element (1 <= i <= M) of the d factor is\nC                   exactly zero; the UdU\' (or LdL\') factorization has\nC                   been completed, but the block diagonal matrix d is\nC                   exactly singular;\nC             = M+1:  if the matrix R is numerically singular.\nC\nC     METHOD\nC                            -     -\nC     The matrices G, and/or A and Q are evaluated using the given or\nC     computed symmetric factorization of R.\nC\nC     NUMERICAL ASPECTS\nC\nC     The routine should not be used when R is ill-conditioned.\nC\nC     CONTRIBUTOR\nC\nC     Release 3.0: V. Sima, Katholieke Univ. Leuven, Belgium, Sep. 1997.\nC\nC     REVISIONS\nC\nC     -\nC\nC     KEYWORDS\nC\nC     Algebraic Riccati equation, closed loop system, continuous-time\nC     system, discrete-time system, optimal regulator, Schur form.\nC\nC     ******************************************************************\n"""\nC\nC     .. Parameters ..\n      DOUBLE PRECISION  ZERO, ONE\n      PARAMETER         ( ZERO = 0.0D0, ONE = 1.0D0 )\nC     .. Scalar Arguments ..\n      CHARACTER         FACT, JOBG, JOBL, UPLO\n      INTEGER           INFO, LDA, LDB, LDG, LDL, LDQ, LDR, LDWORK, M,\n     $                  N, OUFACT\nC     .. Array Arguments ..\n      INTEGER           IPIV(*), IWORK(*)\n      DOUBLE PRECISION  A(LDA,*), B(LDB,*), DWORK(*), G(LDG,*),\n     $                  L(LDL,*), Q(LDQ,*), R(LDR,*)\nC     .. Local Scalars ..\n      LOGICAL           LFACTA, LFACTC, LFACTU, LJOBG, LJOBL, LUPLOU\n      CHARACTER         TRANS\n      INTEGER           I, J, WRKOPT\n      DOUBLE PRECISION  EPS, RCOND, RNORM\nC     .. External Functions ..\n      LOGICAL           LSAME\n      DOUBLE PRECISION  DLAMCH, DLANSY\n      EXTERNAL          DLAMCH, DLANSY, LSAME\nC     .. External Subroutines ..\n      EXTERNAL          DCOPY, DGEMM, DGEMV, DPOCON, DPOTRF, DSYCON,\n     $                  DSYRK, DSYTRF, DSYTRS, DTRSM, XERBLA\nC     .. Intrinsic Functions ..\n      INTRINSIC         INT, MAX\nC     .. Executable Statements ..\nC\n      INFO   = 0\n      LJOBG  = LSAME( JOBG, \'G\' )\n      LJOBL  = LSAME( JOBL, \'N\' )\n      LFACTC = LSAME( FACT, \'C\' )\n      LFACTU = LSAME( FACT, \'U\' )\n      LUPLOU = LSAME( UPLO, \'U\' )\n      LFACTA = LFACTC or LFACTU\nC\nC     Test the input scalar arguments.\nC\n      IF(  not LJOBG  and   not LSAME( JOBG, \'N\' ) ) THEN\n         INFO = -1\n      ELSE IF(  not LJOBL  and   not LSAME( JOBL, \'Z\' ) ) THEN\n         INFO = -2\n      ELSE IF(  not LFACTA  and   not LSAME( FACT, \'N\' ) ) THEN\n         INFO = -3\n      ELSE IF(  not LUPLOU  and   not LSAME( UPLO, \'L\' ) ) THEN\n         INFO = -4\n      ELSE IF( N < 0 ) THEN\n         INFO = -5\n      ELSE IF( M < 0 ) THEN\n         INFO = -6\n      ELSE IF( ( LDA < 1 )  or  ( LJOBL  and  LDA < N ) ) THEN\n         INFO = -8\n      ELSE IF( LDB < MAX( 1, N ) ) THEN\n         INFO = -10\n      ELSE IF( ( LDQ < 1 )  or  ( LJOBL  and  LDQ < N ) ) THEN\n         INFO = -12\n      ELSE IF( LDR < MAX( 1, M ) ) THEN\n         INFO = -14\n      ELSE IF( ( LDL < 1 )  or  ( LJOBL  and  LDL < N ) ) THEN\n         INFO = -16\n      ELSE IF( ( LDG < 1 )  or  ( LJOBG  and  LDG < N ) ) THEN\n         INFO = -20\n      ELSE IF( ( LFACTC  and  LDWORK < 1 )  or \n     $         ( LFACTU  and  LDWORK < MAX( 1, N*M ) )  or \n     $    (  not LFACTA  and  LDWORK < MAX( 2, N*M, 3*M ) ) ) THEN\n         INFO = -23\n      END IF\nC\n      IF ( INFO != 0 ) THEN\nC\nC        Error return.\nC\n         CALL XERBLA( \'sb02mt\', -INFO )\n         RETURN\n      END IF\nC\n      IF ( LFACTC ) THEN\n         OUFACT = 1\n      ELSE IF ( LFACTU ) THEN\n         OUFACT = 2\n      END IF\nC\nC     Quick return if possible.\nC\n      IF ( N == 0  or  M == 0  or   not ( LJOBL or LJOBG ) ) THEN\n        DWORK(1) = ONE\n        IF (  not LFACTA ) DWORK(2) = ONE\n        RETURN\n      END IF\nC\nC     (Note: Comments in the code beginning "Workspace:" describe the\nC     minimal amount of workspace needed at that point in the code,\nC     as well as the preferred amount for good performance.\nC     NB refers to the optimal block size for the immediately\nC     following subroutine, as returned by ILAENV.)\nC\n      WRKOPT = 1\nC\nC     Set relative machine precision.\nC\n      EPS = DLAMCH( \'Epsilon\' )\nC\n      IF (  not LFACTA ) THEN\nC\nC        Compute the norm of the matrix R, which is not factored.\nC        Then save the given triangle of R in the other strict triangle\nC        and the diagonal in the workspace, and try Cholesky\nC        factorization.\nC        Workspace: need M.\nC\n         RNORM = DLANSY( \'1-norm\', UPLO, M, R, LDR, DWORK )\n         CALL DCOPY( M, R, LDR+1, DWORK, 1 )\n         IF( LUPLOU ) THEN\nC\n            DO 20 J = 2, M\n               CALL DCOPY( J-1, R(1,J), 1, R(J,1), LDR )\n   20       CONTINUE\nC\n         ELSE\nC\n            DO 40 J = 2, M\n               CALL DCOPY( J-1, R(J,1), LDR, R(1,J), 1 )\n   40       CONTINUE\nC\n         END IF\n         CALL DPOTRF( UPLO, M, R, LDR, INFO )\n         IF( INFO == 0 ) THEN\nC\nC           Compute the reciprocal of the condition number of R.\nC           Workspace: need 3*M.\nC\n            CALL DPOCON( UPLO, M, R, LDR, RNORM, RCOND, DWORK, IWORK,\n     $                   INFO )\nC\nC           Return if the matrix is singular to working precision.\nC\n            OUFACT = 1\n            DWORK(2) = RCOND\n            IF( RCOND < EPS ) THEN\n               INFO = M + 1\n               RETURN\n            END IF\n            WRKOPT = MAX( WRKOPT, 3*M )\n         ELSE\nC\nC           Use UdU\' or LdL\' factorization, first restoring the saved\nC           triangle.\nC\n            CALL DCOPY( M, DWORK, 1, R, LDR+1 )\n            IF( LUPLOU ) THEN\nC\n               DO 60 J = 2, M\n                  CALL DCOPY( J-1, R(J,1), LDR, R(1,J), 1 )\n   60          CONTINUE\nC\n            ELSE\nC\n               DO 80 J = 2, M\n                  CALL DCOPY( J-1, R(1,J), 1, R(J,1), LDR )\n   80          CONTINUE\nC\n            END IF\nC\nC           Compute the UdU\' or LdL\' factorization.\nC           Workspace: need   1,\nC                      prefer M*NB.\nC\n            CALL DSYTRF( UPLO, M, R, LDR, IPIV, DWORK, LDWORK, INFO )\n            OUFACT = 2\n            IF( INFO > 0 ) THEN\n               DWORK(2) = ONE\n               RETURN\n            END IF\n            WRKOPT = MAX( WRKOPT, INT( DWORK(1) ) )\nC\nC           Compute the reciprocal of the condition number of R.\nC           Workspace: need 2*M.\nC\n            CALL DSYCON( UPLO, M, R, LDR, IPIV, RNORM, RCOND, DWORK,\n     $                   IWORK, INFO )\nC\nC           Return if the matrix is singular to working precision.\nC\n            DWORK(2) = RCOND\n            IF( RCOND < EPS ) THEN\n               INFO = M + 1\n               RETURN\n            END IF\n         END IF\n      END IF\nC\n      IF (OUFACT == 1 ) THEN\nC\nC        Solve positive definite linear system(s).\nC\n         IF ( LUPLOU ) THEN\n            TRANS = \'N\'\n         ELSE\n            TRANS = \'T\'\n         END IF\nC\nC        Solve the system X*U = B, overwriting B with X.\nC\n         CALL DTRSM( \'Right\', UPLO, TRANS, \'Non-unit\', N, M,\n     $               ONE, R, LDR, B, LDB )\nC\n         IF ( LJOBG ) THEN\nC                                      -1\nC           Compute the matrix  G = B*R  *B\', multiplying X*X\' in G.\nC\n            CALL DSYRK( UPLO, \'No transpose\', N, M, ONE, B, LDB, ZERO,\n     $                  G, LDG )\n         END IF\nC\n         IF( LJOBL ) THEN\nC\nC           Update matrices A and Q.\nC\nC           Solve the system Y*U = L, overwriting L with Y.\nC\n            CALL DTRSM( \'Right\', UPLO, TRANS, \'Non-unit\', N, M,\n     $                  ONE, R, LDR, L, LDL )\nC\nC           Compute A <- A - X*Y\'.\nC\n            CALL DGEMM( \'No transpose\', \'Transpose\', N, N, M, -ONE, B,\n     $                  LDB, L, LDL, ONE, A, LDA )\nC\nC           Compute Q <- Q - Y*Y\'.\nC\n            CALL DSYRK( UPLO, \'No transpose\', N, M, -ONE, L, LDL, ONE,\n     $                  Q, LDQ )\n         END IF\n      ELSE\nC\nC        Solve indefinite linear system(s).\nC\nC        Solve the system UdU\'*X = B\' (or LdL\'*X = B\').\nC        Workspace: need N*M.\nC\n         DO 100 J = 1, M\n            CALL DCOPY( N, B(1,J), 1, DWORK(J), M )\n  100    CONTINUE\nC\n         CALL DSYTRS( UPLO, M, N, R, LDR, IPIV, DWORK, M, INFO )\nC\n         IF ( LJOBG ) THEN\nC                                                    -1\nC           Compute a triangle of the matrix  G = B*R  *B\' = B*X.\nC\n            IF ( LUPLOU ) THEN\n               I = 1\nC\n               DO 120 J = 1, N\n                  CALL DGEMV( \'No transpose\', J, M, ONE, B, LDB,\n     $                        DWORK(I), 1, ZERO, G(1,J), 1 )\n                  I = I + M\n  120          CONTINUE\nC\n            ELSE\nC\n               DO 140 J = 1, N\n                  CALL DGEMV( \'Transpose\', M, J, ONE, DWORK, M, B(J,1),\n     $                        LDB, ZERO, G(J,1), LDG )\n  140          CONTINUE\nC\n            END IF\n         END IF\nC\n         IF( LJOBL ) THEN\nC\nC           Update matrices A and Q.\nC\nC           Solve the system UdU\'*Y = L\' (or LdL\'*Y = L\').\nC\n            DO 160 J = 1, M\n               CALL DCOPY( N, L(1,J), 1, DWORK(J), M )\n  160       CONTINUE\nC\n            CALL DSYTRS( UPLO, M, N, R, LDR, IPIV, DWORK, M, INFO )\nC\nC           A <- A - B*Y.\nC\n            CALL DGEMM( \'No transpose\', \'No transpose\', N, N, M, -ONE,\n     $                  B, LDB, DWORK, M, ONE, A, LDA )\nC                                            -          -1\nC           Compute a triangle of the matrix Q = Q - L*R  *L\' = Q - L*Y.\nC\n            IF ( LUPLOU ) THEN\n               I = 1\nC\n               DO 180 J = 1, N\n                  CALL DGEMV( \'No transpose\', J, M, -ONE, L, LDL,\n     $                        DWORK(I), 1, ONE, Q(1,J), 1 )\n                  I = I + M\n  180          CONTINUE\nC\n            ELSE\nC\n               DO 200 J = 1, N\n                  CALL DGEMV( \'Transpose\', M, J, -ONE, DWORK, M, L(J,1),\n     $                        LDL, ONE, Q(J,1), LDQ )\n  200          CONTINUE\nC\n            END IF\n         END IF\n      END IF\nC\n      DWORK(1) = WRKOPT\n      IF (  not LFACTA ) DWORK(2) = RCOND\nC\nC *** Last line of SB02MT ***\n      RETURN\n      END\n')

        result = f2pe.replace_logical_operators(fortran_code)
        self.assertEqual(expected, result)

    def test_replace_else_if_00(self):
        code = '''      IF( .NOT.LJOBG .AND. .NOT.LSAME( JOBG, 'N' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.LJOBL .AND. .NOT.LSAME( JOBL, 'Z' ) ) THEN'''

        expected = '''      IF( .NOT.LJOBG .AND. .NOT.LSAME( JOBG, 'N' ) ) THEN
         INFO = -1
      elif ( .NOT.LJOBL .AND. .NOT.LSAME( JOBL, 'Z' ) ) THEN'''

        result = f2pe.replace_else_if(code)

        self.assertEqual(expected, result)

    def test_replace_else_if_01(self):
        code = '''      IF( .NOT.LJOBG .AND. .NOT.LSAME( JOBG, 'N' ) ) THEN
         INFO = -1
      ELSE IF ( .NOT.LJOBL .AND. .NOT.LSAME( JOBL, 'Z' ) ) THEN'''

        expected = '''      IF( .NOT.LJOBG .AND. .NOT.LSAME( JOBG, 'N' ) ) THEN
         INFO = -1
      elif ( .NOT.LJOBL .AND. .NOT.LSAME( JOBL, 'Z' ) ) THEN'''

        result = f2pe.replace_else_if(code)

        self.assertEqual(expected, result)

    def test_replace_two_word_keywords(self):
        code = '''C
C     Test the input scalar arguments.
C
      IF( .NOT.LJOBG .AND. .NOT.LSAME( JOBG, 'N' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.LJOBL .AND. .NOT.LSAME( JOBL, 'Z' ) ) THEN
         INFO = -2
      sELSE IF( .NOT.LFACTA .AND. .NOT.LSAME( FACT, 'N' ) ) THEN
         INFO = -3
      ELSE IFs( .NOT.LUPLOU .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -4
      ELSE IF( N.LT.0 ) THEN
         INFO = -5
      ELSE IF( M.LT.0 ) THEN
         INFO = -6
      ELSE IF( ( LDA.LT.1 ) .OR. ( LJOBL .AND. LDA.LT.N ) ) THEN
         INFO = -8
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -10
      ELSE IF( ( LDQ.LT.1 ) .OR. ( LJOBL .AND. LDQ.LT.N ) ) THEN
         INFO = -12
      ELSE IF( LDR.LT.MAX( 1, M ) ) THEN
         INFO = -14
      ELSE IF ( ( LDL.LT.1 ) .OR. ( LJOBL .AND. LDL.LT.N ) ) THEN
         INFO = -16
      ELSE IF ( ( LDG.LT.1 ) .OR. ( LJOBG .AND. LDG.LT.N ) ) THEN
         INFO = -20
      ELSE IF( ( LFACTC .AND. LDWORK.LT.1 ) .OR.
     $         ( LFACTU .AND. LDWORK.LT.MAX( 1, N*M ) ) .OR.
     $    ( .NOT.LFACTA .AND. LDWORK.LT.MAX( 2, N*M, 3*M ) ) ) THEN
         INFO = -23
      END IF
C
'''
        expected = '''C
C     Test the input scalar arguments.
C
      IF( .NOT.LJOBG .AND. .NOT.LSAME( JOBG, 'N' ) ) THEN
         INFO = -1
      elif ( .NOT.LJOBL .AND. .NOT.LSAME( JOBL, 'Z' ) ) THEN
         INFO = -2
      sELSE IF( .NOT.LFACTA .AND. .NOT.LSAME( FACT, 'N' ) ) THEN
         INFO = -3
      ELSE IFs( .NOT.LUPLOU .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -4
      elif ( N.LT.0 ) THEN
         INFO = -5
      elif ( M.LT.0 ) THEN
         INFO = -6
      elif ( ( LDA.LT.1 ) .OR. ( LJOBL .AND. LDA.LT.N ) ) THEN
         INFO = -8
      elif ( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -10
      elif ( ( LDQ.LT.1 ) .OR. ( LJOBL .AND. LDQ.LT.N ) ) THEN
         INFO = -12
      elif ( LDR.LT.MAX( 1, M ) ) THEN
         INFO = -14
      elif ( ( LDL.LT.1 ) .OR. ( LJOBL .AND. LDL.LT.N ) ) THEN
         INFO = -16
      elif ( ( LDG.LT.1 ) .OR. ( LJOBG .AND. LDG.LT.N ) ) THEN
         INFO = -20
      elif ( ( LFACTC .AND. LDWORK.LT.1 ) .OR.
     $         ( LFACTU .AND. LDWORK.LT.MAX( 1, N*M ) ) .OR.
     $    ( .NOT.LFACTA .AND. LDWORK.LT.MAX( 2, N*M, 3*M ) ) ) THEN
         INFO = -23
      # end_if
C
'''
        result = f2pe.replace_two_word_keywords(code)
        self.assertEqual(expected, result)

    def test_replace_continue(self):
        code = '''
                 RNORM = DLANSY( '1-norm', UPLO, M, R, LDR, DWORK )
                 CALL DCOPY( M, R, LDR+1, DWORK, 1 )
                 IF( LUPLOU ) THEN
        C
                    DO 20 J = 2, M
                       CALL DCOPY( J-1, R(1,J), 1, R(J,1), LDR )
           20       CONTINUE
        C
                 ELSE
        C
                    DO 40 J = 2, M
                       CALL DCOPY( J-1, R(J,1), LDR, R(1,J), 1 )
           40       CONTINUE
        C
                 END IF
                 CALL DPOTRF( UPLO, M, R, LDR, INFO )
        '''

        expected = '''
                 RNORM = DLANSY( '1-norm', UPLO, M, R, LDR, DWORK )
                 CALL DCOPY( M, R, LDR+1, DWORK, 1 )
                 IF( LUPLOU ) THEN
        C
                    DO 20 J = 2, M
                       CALL DCOPY( J-1, R(1,J), 1, R(J,1), LDR )
           # end_for 20
        C
                 ELSE
        C
                    DO 40 J = 2, M
                       CALL DCOPY( J-1, R(J,1), LDR, R(1,J), 1 )
           # end_for 40
        C
                 END IF
                 CALL DPOTRF( UPLO, M, R, LDR, INFO )
        '''
        result = f2pe.replace_continue(code)
        self.assertEqual(expected, result)

    def test_decide_indent_level(self):
        python_list = ['#      SUBROUTINE SB02MT (  JOBG, JOBL, FACT, UPLO, N, M, A, LDA, B, LDB,',
                       '#     $                   Q, LDQ, R, LDR, L, LDL, IPIV, OUFACT, G, LDG,',
                       '#     $                   IWORK, DWORK, LDWORK, INFO  ) ',
                       ['SUBROUTINE', 'SB02MT', '(', 'JOBG', 'JOBL', 'FACT', 'UPLO', 'N', 'M', 'A', 'LDA', 'B', 'LDB',
                        'Q', 'LDQ', 'R', 'LDR', 'L', 'LDL', 'IPIV', 'OUFACT', 'G', 'LDG', 'IWORK', 'DWORK', 'LDWORK',
                        'INFO', ')'],
                       '#',
                       '#     SLICOT RELEASE 5.0.',
                       '#',
                       '#     Copyright (c) 2002-2009 NICONET e.V.',
                       '#',
                       '#     This program is free software: you can redistribute it and/or',
                       '#     modify it under the terms of the GNU General Public License as',
                       '#     published by the Free Software Foundation, either version 2 of',
                       '#     the License, or (at your option) any later version.',
                       '#',
                       '#     This program is distributed in the hope that it will be useful,',
                       '#     but WITHOUT ANY WARRANTY; without even the implied warranty of',
                       '#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the',
                       '#     GNU General Public License for more details.',
                       '#',
                       '#     You should have received a copy of the GNU General Public License',
                       '#     along with this program.  If not, see',
                       '#     <http://www.gnu.org/licenses/>.',
                       '#',
                       '#     PURPOSE',
                       '#',
                       '#     To compute the following matrices',
                       '#',
                       '#                -1',
                       "#         G = B*R  *B',",
                       '#',
                       '#         -          -1',
                       "#         A = A - B*R  *L',",
                       '#',
                       '#         -          -1',
                       "#         Q = Q - L*R  *L',",
                       '#',
                       '#     where A, B, Q, R, L, and G are N-by-N, N-by-M, N-by-N, M-by-M,',
                       '#     N-by-M, and N-by-N matrices, respectively, with Q, R and G',
                       '#     symmetric matrices.',
                       '#',
                       '#     When R is well-conditioned with respect to inversion, standard',
                       '#     algorithms for solving linear-quadratic optimization problems will',
                       '#     then also solve optimization problems with coupling weighting',
                       '#     matrix L. Moreover, a gain in efficiency is possible using matrix',
                       '#     G in the deflating subspace algorithms (see SLICOT Library routine',
                       '#     SB02OD).',
                       '#',
                       '#     ARGUMENTS',
                       '#',
                       '#     Mode Parameters',
                       '#',
                       '#     JOBG    CHARACTER*1',
                       '#             Specifies whether or not the matrix G is to be computed,',
                       '#             as follows:',
                       "#             = 'G':  Compute G;",
                       "#             = 'N':  Do not compute G.",
                       '#',
                       '#     JOBL    CHARACTER*1',
                       '#             Specifies whether or not the matrix L is zero, as follows:',
                       "#             = 'Z':  L is zero;",
                       "#             = 'N':  L is nonzero.",
                       '#',
                       '#     FACT    CHARACTER*1',
                       '#             Specifies how the matrix R is given (factored or not), as',
                       '#             follows:',
                       "#             = 'N':  Array R contains the matrix R;",
                       "#             = 'C':  Array R contains the Cholesky factor of R;",
                       "#             = 'U':  Array R contains the symmetric indefinite UdU' or",
                       "#                     LdL' factorization of R.",
                       '#',
                       '#     UPLO    CHARACTER*1',
                       '#             Specifies which triangle of the matrices R and Q (if',
                       "#             JOBL = 'N') is stored, as follows:",
                       "#             = 'U':  Upper triangle is stored;",
                       "#             = 'L':  Lower triangle is stored.",
                       '#',
                       '#     Input/Output Parameters',
                       '#',
                       '#     N       (input) INTEGER',
                       '#             The order of the matrices A, Q, and G, and the number of',
                       '#             rows of the matrices B and L.  N >= 0.',
                       '#',
                       '#     M       (input) INTEGER',
                       '#             The order of the matrix R, and the number of columns of',
                       '#             the matrices B and L.  M >= 0.',
                       '#',
                       '#     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)',
                       "#             On entry, if JOBL = 'N', the leading N-by-N part of this",
                       '#             array must contain the matrix A.',
                       "#             On exit, if JOBL = 'N', and INFO = 0, the leading N-by-N",
                       '#                                                    -          -1',
                       "#             part of this array contains the matrix A = A - B*R  L'.",
                       "#             If JOBL = 'Z', this array is not referenced.",
                       '#',
                       '#     LDA     INTEGER',
                       '#             The leading dimension of array A.',
                       "#             LDA >= MAX(1,N) if JOBL = 'N';",
                       "#             LDA >= 1        if JOBL = 'Z'.",
                       '#',
                       '#     B       (input/output) DOUBLE PRECISION array, dimension (LDB,M)',
                       '#             On entry, the leading N-by-M part of this array must',
                       '#             contain the matrix B.',
                       '#             On exit, if OUFACT = 1, and INFO = 0, the leading N-by-M',
                       '#                                                             -1',
                       '#             part of this array contains the matrix B*chol(R)  .',
                       '#             On exit, B is unchanged if OUFACT = 2 (hence also when',
                       "#             FACT = 'U').",
                       '#',
                       '#     LDB     INTEGER',
                       '#             The leading dimension of array B.  LDB >= MAX(1,N).',
                       '#',
                       '#     Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)',
                       "#             On entry, if JOBL = 'N', the leading N-by-N upper",
                       "#             triangular part (if UPLO = 'U') or lower triangular part",
                       "#             (if UPLO = 'L') of this array must contain the upper",
                       '#             triangular part or lower triangular part, respectively, of',
                       '#             the symmetric matrix Q. The stricly lower triangular part',
                       "#             (if UPLO = 'U') or stricly upper triangular part (if",
                       "#             UPLO = 'L') is not referenced.",
                       "#             On exit, if JOBL = 'N' and INFO = 0, the leading N-by-N",
                       "#             upper triangular part (if UPLO = 'U') or lower triangular",
                       "#             part (if UPLO = 'L') of this array contains the upper",
                       '#             triangular part or lower triangular part, respectively, of',
                       '#                                  -          -1',
                       "#             the symmetric matrix Q = Q - L*R  *L'.",
                       "#             If JOBL = 'Z', this array is not referenced.",
                       '#',
                       '#     LDQ     INTEGER',
                       '#             The leading dimension of array Q.',
                       "#             LDQ >= MAX(1,N) if JOBL = 'N';",
                       "#             LDQ >= 1        if JOBL = 'Z'.",
                       '#',
                       '#     R       (input/output) DOUBLE PRECISION array, dimension (LDR,M)',
                       "#             On entry, if FACT = 'N', the leading M-by-M upper",
                       "#             triangular part (if UPLO = 'U') or lower triangular part",
                       "#             (if UPLO = 'L') of this array must contain the upper",
                       '#             triangular part or lower triangular part, respectively,',
                       '#             of the symmetric input weighting matrix R.',
                       "#             On entry, if FACT = 'C', the leading M-by-M upper",
                       "#             triangular part (if UPLO = 'U') or lower triangular part",
                       "#             (if UPLO = 'L') of this array must contain the Cholesky",
                       '#             factor of the positive definite input weighting matrix R',
                       '#             (as produced by LAPACK routine DPOTRF).',
                       "#             On entry, if FACT = 'U', the leading M-by-M upper",
                       "#             triangular part (if UPLO = 'U') or lower triangular part",
                       "#             (if UPLO = 'L') of this array must contain the factors of",
                       "#             the UdU' or LdL' factorization, respectively, of the",
                       '#             symmetric indefinite input weighting matrix R (as produced',
                       '#             by LAPACK routine DSYTRF).',
                       "#             If FACT = 'N', the stricly lower triangular part (if UPLO",
                       "#             = 'U') or stricly upper triangular part (if UPLO = 'L') of",
                       '#             this array is used as workspace.',
                       '#             On exit, if OUFACT = 1, and INFO = 0 (or INFO = M+1),',
                       "#             the leading M-by-M upper triangular part (if UPLO = 'U')",
                       "#             or lower triangular part (if UPLO = 'L') of this array",
                       '#             contains the Cholesky factor of the given input weighting',
                       '#             matrix.',
                       '#             On exit, if OUFACT = 2, and INFO = 0 (or INFO = M+1),',
                       "#             the leading M-by-M upper triangular part (if UPLO = 'U')",
                       "#             or lower triangular part (if UPLO = 'L') of this array",
                       "#             contains the factors of the UdU' or LdL' factorization,",
                       '#             respectively, of the given input weighting matrix.',
                       "#             On exit R is unchanged if FACT = 'C' or 'U'.",
                       '#',
                       '#     LDR     INTEGER',
                       '#             The leading dimension of array R.  LDR >= MAX(1,M).',
                       '#',
                       '#     L       (input/output) DOUBLE PRECISION array, dimension (LDL,M)',
                       "#             On entry, if JOBL = 'N', the leading N-by-M part of this",
                       '#             array must contain the matrix L.',
                       "#             On exit, if JOBL = 'N', OUFACT = 1, and INFO = 0, the",
                       '#             leading N-by-M part of this array contains the matrix',
                       '#                      -1',
                       '#             L*chol(R)  .',
                       '#             On exit, L is unchanged if OUFACT = 2 (hence also when',
                       "#             FACT = 'U').",
                       "#             L is not referenced if JOBL = 'Z'.",
                       '#',
                       '#     LDL     INTEGER',
                       '#             The leading dimension of array L.',
                       "#             LDL >= MAX(1,N) if JOBL = 'N';",
                       "#             LDL >= 1        if JOBL = 'Z'.",
                       '#',
                       '#     IPIV    (input/output) INTEGER array, dimension (M)',
                       "#             On entry, if FACT = 'U', this array must contain details",
                       '#             of the interchanges performed and the block structure of',
                       "#             the d factor in the UdU' or LdL' factorization of matrix R",
                       '#             (as produced by LAPACK routine DSYTRF).',
                       '#             On exit, if OUFACT = 2, this array contains details of',
                       '#             the interchanges performed and the block structure of the',
                       "#             d factor in the UdU' or LdL' factorization of matrix R,",
                       '#             as produced by LAPACK routine DSYTRF.',
                       "#             This array is not referenced if FACT = 'C'.",
                       '#',
                       '#     OUFACT  (output) INTEGER',
                       '#             Information about the factorization finally used.',
                       '#             OUFACT = 1:  Cholesky factorization of R has been used;',
                       "#             OUFACT = 2:  UdU' (if UPLO = 'U') or LdL' (if UPLO = 'L')",
                       '#                          factorization of R has been used.',
                       '#',
                       '#     G       (output) DOUBLE PRECISION array, dimension (LDG,N)',
                       "#             If JOBG = 'G', and INFO = 0, the leading N-by-N upper",
                       "#             triangular part (if UPLO = 'U') or lower triangular part",
                       "#             (if UPLO = 'L') of this array contains the upper",
                       "#             triangular part (if UPLO = 'U') or lower triangular part",
                       '#                                                                 -1',
                       "#             (if UPLO = 'L'), respectively, of the matrix G = B*R  B'.",
                       "#             If JOBG = 'N', this array is not referenced.",
                       '#',
                       '#     LDG     INTEGER',
                       '#             The leading dimension of array G.',
                       "#             LDG >= MAX(1,N) if JOBG = 'G',",
                       "#             LDG >= 1        if JOBG = 'N'.",
                       '#',
                       '#     Workspace',
                       '#',
                       '#     IWORK   INTEGER array, dimension (M)',
                       '#',
                       '#     DWORK   DOUBLE PRECISION array, dimension (LDWORK)',
                       '#             On exit, if INFO = 0, DWORK(1) returns the optimal value',
                       "#             of LDWORK; if FACT = 'N', DWORK(2) contains the reciprocal",
                       '#             condition number of the given matrix R.',
                       '#',
                       '#     LDWORK  INTEGER',
                       '#             The length of the array DWORK.',
                       "#             LDWORK >= 1              if FACT = 'C';",
                       "#             LDWORK >= MAX(2,3*M,N*M) if FACT = 'N';",
                       "#             LDWORK >= MAX(1,N*M)     if FACT = 'U'.",
                       '#             For optimum performance LDWORK should be larger than 3*M,',
                       "#             if FACT = 'N'.",
                       "#             The N*M workspace is not needed for FACT = 'N', if matrix",
                       '#             R is positive definite.',
                       '#',
                       '#     Error Indicator',
                       '#',
                       '#     INFO    INTEGER',
                       '#             = 0:  successful exit;',
                       '#             < 0:  if INFO = -i, the i-th argument had an illegal',
                       '#                   value;',
                       '#             = i:  if the i-th element (1 <= i <= M) of the d factor is',
                       "#                   exactly zero; the UdU' (or LdL') factorization has",
                       '#                   been completed, but the block diagonal matrix d is',
                       '#                   exactly singular;',
                       '#             = M+1:  if the matrix R is numerically singular.',
                       '#',
                       '#     METHOD',
                       '#                            -     -',
                       '#     The matrices G, and/or A and Q are evaluated using the given or',
                       '#     computed symmetric factorization of R.',
                       '#',
                       '#     NUMERICAL ASPECTS',
                       '#',
                       '#     The routine should not be used when R is ill-conditioned.',
                       '#',
                       '#     CONTRIBUTOR',
                       '#',
                       '#     Release 3.0: V. Sima, Katholieke Univ. Leuven, Belgium, Sep. 1997.',
                       '#',
                       '#     REVISIONS',
                       '#',
                       '#     -',
                       '#',
                       '#     KEYWORDS',
                       '#',
                       '#     Algebraic Riccati equation, closed loop system, continuous-time',
                       '#     system, discrete-time system, optimal regulator, Schur form.',
                       '#',
                       '#     ******************************************************************',
                       '#""',
                       '#',
                       '#     .. Parameters ..',
                       '#      DOUBLE PRECISION  ZERO, ONE',
                       ['DOUBLE', 'PRECISION', 'ZERO', 'ONE'],
                       '#      PARAMETER          (  ZERO = 0.0D0, ONE = 1.0D0  ) ',
                       ['PARAMETER', '(', 'ZERO', '=', '0.0D0', 'ONE', '=', '1.0D0', ')'],
                       '#     .. Scalar Arguments ..',
                       '#      CHARACTER         FACT, JOBG, JOBL, UPLO',
                       ['CHARACTER', 'FACT', 'JOBG', 'JOBL', 'UPLO'],
                       '#      INTEGER           INFO, LDA, LDB, LDG, LDL, LDQ, LDR, LDWORK, M,',
                       '#     $                  N, OUFACT',
                       ['INTEGER', 'INFO', 'LDA', 'LDB', 'LDG', 'LDL', 'LDQ', 'LDR', 'LDWORK', 'M', 'N', 'OUFACT'],
                       '#     .. Array Arguments ..',
                       '#      INTEGER           IPIV ( * ) , IWORK ( * ) ',
                       ['INTEGER', 'IPIV', '(', '*', ')', 'IWORK', '(', '*', ')'],
                       '#      DOUBLE PRECISION  A ( LDA,* ) , B ( LDB,* ) , DWORK ( * ) , G ( LDG,* ) ,',
                       '#     $                  L ( LDL,* ) , Q ( LDQ,* ) , R ( LDR,* ) ',
                       ['DOUBLE', 'PRECISION', 'A', '(', 'LDA', '*', ')', 'B', '(', 'LDB', '*', ')', 'DWORK', '(', '*',
                        ')', 'G', '(', 'LDG', '*', ')', 'L', '(', 'LDL', '*', ')', 'Q', '(', 'LDQ', '*', ')', 'R', '(',
                        'LDR', '*', ')'],
                       '#     .. Local Scalars ..',
                       '#      LOGICAL           LFACTA, LFACTC, LFACTU, LJOBG, LJOBL, LUPLOU',
                       ['LOGICAL', 'LFACTA', 'LFACTC', 'LFACTU', 'LJOBG', 'LJOBL', 'LUPLOU'],
                       '#      CHARACTER         TRANS',
                       ['CHARACTER', 'TRANS'],
                       '#      INTEGER           I, J, WRKOPT',
                       ['INTEGER', 'I', 'J', 'WRKOPT'],
                       '#      DOUBLE PRECISION  EPS, RCOND, RNORM',
                       ['DOUBLE', 'PRECISION', 'EPS', 'RCOND', 'RNORM'],
                       '#     .. External Functions ..',
                       '#      LOGICAL           LSAME',
                       ['LOGICAL', 'LSAME'],
                       '#      DOUBLE PRECISION  DLAMCH, DLANSY',
                       ['DOUBLE', 'PRECISION', 'DLAMCH', 'DLANSY'],
                       '#      EXTERNAL          DLAMCH, DLANSY, LSAME',
                       ['EXTERNAL', 'DLAMCH', 'DLANSY', 'LSAME'],
                       '#     .. External Subroutines ..',
                       '#      EXTERNAL          DCOPY, DGEMM, DGEMV, DPOCON, DPOTRF, DSYCON,',
                       '#     $                  DSYRK, DSYTRF, DSYTRS, DTRSM, XERBLA',
                       ['EXTERNAL', 'DCOPY', 'DGEMM', 'DGEMV', 'DPOCON', 'DPOTRF', 'DSYCON', 'DSYRK', 'DSYTRF',
                        'DSYTRS', 'DTRSM', 'XERBLA'],
                       '#     .. Intrinsic Functions ..',
                       '#      INTRINSIC         INT, MAX',
                       ['INTRINSIC', 'INT', 'MAX'],
                       '#     .. Executable Statements ..',
                       '#',
                       '#      INFO   = 0',
                       ['INFO', '=', '0'],
                       "#      LJOBG  = LSAME (  JOBG, 'G'  ) ",
                       ['LJOBG', '=', 'LSAME', '(', 'JOBG', "'G'", ')'],
                       "#      LJOBL  = LSAME (  JOBL, 'N'  ) ",
                       ['LJOBL', '=', 'LSAME', '(', 'JOBL', "'N'", ')'],
                       "#      LFACTC = LSAME (  FACT, 'C'  ) ",
                       ['LFACTC', '=', 'LSAME', '(', 'FACT', "'C'", ')'],
                       "#      LFACTU = LSAME (  FACT, 'U'  ) ",
                       ['LFACTU', '=', 'LSAME', '(', 'FACT', "'U'", ')'],
                       "#      LUPLOU = LSAME (  UPLO, 'U'  ) ",
                       ['LUPLOU', '=', 'LSAME', '(', 'UPLO', "'U'", ')'],
                       '#      LFACTA = LFACTC or LFACTU',
                       ['LFACTA', '=', 'LFACTC', 'or', 'LFACTU'],
                       '#',
                       '#     Test the input scalar arguments.',
                       '#',
                       "#      IF (   not LJOBG  and   not LSAME (  JOBG, 'N'  )   )  THEN",
                       ['IF', '(', 'not', 'LJOBG', 'and', 'not', 'LSAME', '(', 'JOBG', "'N'", ')', ')', 'THEN'],
                       '#         INFO = -1',
                       ['INFO', '=', '-1'],
                       "#      elif (   not LJOBL  and   not LSAME (  JOBL, 'Z'  )   )  THEN",
                       ['elif', '(', 'not', 'LJOBL', 'and', 'not', 'LSAME', '(', 'JOBL', "'Z'", ')', ')', 'THEN'],
                       '#         INFO = -2',
                       ['INFO', '=', '-2'],
                       "#      elif (   not LFACTA  and   not LSAME (  FACT, 'N'  )   )  THEN",
                       ['elif', '(', 'not', 'LFACTA', 'and', 'not', 'LSAME', '(', 'FACT', "'N'", ')', ')', 'THEN'],
                       '#         INFO = -3',
                       ['INFO', '=', '-3'],
                       "#      elif (   not LUPLOU  and   not LSAME (  UPLO, 'L'  )   )  THEN",
                       ['elif', '(', 'not', 'LUPLOU', 'and', 'not', 'LSAME', '(', 'UPLO', "'L'", ')', ')', 'THEN'],
                       '#         INFO = -4',
                       ['INFO', '=', '-4'],
                       '#      elif (  N < 0  )  THEN',
                       ['elif', '(', 'N', '<', '0', ')', 'THEN'],
                       '#         INFO = -5',
                       ['INFO', '=', '-5'],
                       '#      elif (  M < 0  )  THEN',
                       ['elif', '(', 'M', '<', '0', ')', 'THEN'],
                       '#         INFO = -6',
                       ['INFO', '=', '-6'],
                       '#      elif (   (  LDA < 1  )   or   (  LJOBL  and  LDA < N  )   )  THEN',
                       ['elif', '(', '(', 'LDA', '<', '1', ')', 'or', '(', 'LJOBL', 'and', 'LDA', '<', 'N', ')', ')',
                        'THEN'],
                       '#         INFO = -8',
                       ['INFO', '=', '-8'],
                       '#      elif (  LDB < MAX (  1, N  )   )  THEN',
                       ['elif', '(', 'LDB', '<', 'MAX', '(', '1', 'N', ')', ')', 'THEN'],
                       '#         INFO = -10',
                       ['INFO', '=', '-10'],
                       '#      elif (   (  LDQ < 1  )   or   (  LJOBL  and  LDQ < N  )   )  THEN',
                       ['elif', '(', '(', 'LDQ', '<', '1', ')', 'or', '(', 'LJOBL', 'and', 'LDQ', '<', 'N', ')', ')',
                        'THEN'],
                       '#         INFO = -12',
                       ['INFO', '=', '-12'],
                       '#      elif (  LDR < MAX (  1, M  )   )  THEN',
                       ['elif', '(', 'LDR', '<', 'MAX', '(', '1', 'M', ')', ')', 'THEN'],
                       '#         INFO = -14',
                       ['INFO', '=', '-14'],
                       '#      elif (   (  LDL < 1  )   or   (  LJOBL  and  LDL < N  )   )  THEN',
                       ['elif', '(', '(', 'LDL', '<', '1', ')', 'or', '(', 'LJOBL', 'and', 'LDL', '<', 'N', ')', ')',
                        'THEN'],
                       '#         INFO = -16',
                       ['INFO', '=', '-16'],
                       '#      elif (   (  LDG < 1  )   or   (  LJOBG  and  LDG < N  )   )  THEN',
                       ['elif', '(', '(', 'LDG', '<', '1', ')', 'or', '(', 'LJOBG', 'and', 'LDG', '<', 'N', ')', ')',
                        'THEN'],
                       '#         INFO = -20',
                       ['INFO', '=', '-20'],
                       '#      elif (   (  LFACTC  and  LDWORK < 1  )   or ',
                       '#     $          (  LFACTU  and  LDWORK < MAX (  1, N*M  )   )   or ',
                       '#     $     (   not LFACTA  and  LDWORK < MAX (  2, N*M, 3*M  )   )   )  THEN',
                       ['elif', '(', '(', 'LFACTC', 'and', 'LDWORK', '<', '1', ')', 'or', '(', 'LFACTU', 'and',
                        'LDWORK', '<', 'MAX', '(', '1', 'N*M', ')', ')', 'or', '(', 'not', 'LFACTA', 'and', 'LDWORK',
                        '<', 'MAX', '(', '2', 'N*M', '3*M', ')', ')', ')', 'THEN'],
                       '#         INFO = -23',
                       ['INFO', '=', '-23'],
                       '#      # end_if',
                       ['end_if'],
                       '#',
                       '#      IF  (  INFO != 0  )  THEN',
                       ['IF', '(', 'INFO', '!=', '0', ')', 'THEN'],
                       '#',
                       '#        Error return.',
                       '#',
                       "#         CALL XERBLA (  'sb02mt', -INFO  ) ",
                       ['CALL', 'XERBLA', '(', "'sb02mt'", '-INFO', ')'],
                       '#         RETURN',
                       ['RETURN'],
                       '#      # end_if',
                       ['end_if'],
                       '#',
                       '#      IF  (  LFACTC  )  THEN',
                       ['IF', '(', 'LFACTC', ')', 'THEN'],
                       '#         OUFACT = 1',
                       ['OUFACT', '=', '1'],
                       '#      elif  (  LFACTU  )  THEN',
                       ['elif', '(', 'LFACTU', ')', 'THEN'],
                       '#         OUFACT = 2',
                       ['OUFACT', '=', '2'],
                       '#      # end_if',
                       ['end_if'],
                       '#',
                       '#     Quick return if possible.',
                       '#',
                       '#      IF  (  N == 0  or  M == 0  or   not  (  LJOBL or LJOBG  )   )  THEN',
                       ['IF', '(', 'N', '==', '0', 'or', 'M', '==', '0', 'or', 'not', '(', 'LJOBL', 'or', 'LJOBG', ')',
                        ')', 'THEN'],
                       '#        DWORK ( 1 )  = ONE',
                       ['DWORK', '(', '1', ')', '=', 'ONE'],
                       '#        IF  (   not LFACTA  )  DWORK ( 2 )  = ONE',
                       ['IF', '(', 'not', 'LFACTA', ')', 'DWORK', '(', '2', ')', '=', 'ONE'],
                       '#        RETURN',
                       ['RETURN'],
                       '#      # end_if',
                       ['end_if'],
                       '#',
                       '#     (Note: Comments in the code beginning "Workspace:" describe the',
                       '#     minimal amount of workspace needed at that point in the code,',
                       '#     as well as the preferred amount for good performance.',
                       '#     NB refers to the optimal block size for the immediately',
                       '#     following subroutine, as returned by ILAENV.)',
                       '#',
                       '#      WRKOPT = 1',
                       ['WRKOPT', '=', '1'],
                       '#',
                       '#     Set relative machine precision.',
                       '#',
                       "#      EPS = DLAMCH (  'Epsilon'  ) ",
                       ['EPS', '=', 'DLAMCH', '(', "'Epsilon'", ')'],
                       '#',
                       '#      IF  (   not LFACTA  )  THEN',
                       ['IF', '(', 'not', 'LFACTA', ')', 'THEN'],
                       '#',
                       '#        Compute the norm of the matrix R, which is not factored.',
                       '#        Then save the given triangle of R in the other strict triangle',
                       '#        and the diagonal in the workspace, and try Cholesky',
                       '#        factorization.',
                       '#        Workspace: need M.',
                       '#',
                       "#         RNORM = DLANSY (  '1-norm', UPLO, M, R, LDR, DWORK  ) ",
                       ['RNORM', '=', 'DLANSY', '(', "'1-norm'", 'UPLO', 'M', 'R', 'LDR', 'DWORK', ')'],
                       '#         CALL DCOPY (  M, R, LDR+1, DWORK, 1  ) ',
                       ['CALL', 'DCOPY', '(', 'M', 'R', 'LDR+1', 'DWORK', '1', ')'],
                       '#         IF (  LUPLOU  )  THEN',
                       ['IF', '(', 'LUPLOU', ')', 'THEN'],
                       '#',
                       '#            DO 20 J = 2, M',
                       ['DO', '20', 'J', '=', '2', 'M'],
                       '#               CALL DCOPY (  J-1, R ( 1,J ) , 1, R ( J,1 ) , LDR  ) ',
                       ['CALL', 'DCOPY', '(', 'J-1', 'R', '(', '1', 'J', ')', '1', 'R', '(', 'J', '1', ')', 'LDR', ')'],
                       '#   20       CONTINUE',
                       ['20', 'CONTINUE'],
                       '#',
                       '#         ELSE',
                       ['ELSE'],
                       '#',
                       '#            DO 40 J = 2, M',
                       ['DO', '40', 'J', '=', '2', 'M'],
                       '#               CALL DCOPY (  J-1, R ( J,1 ) , LDR, R ( 1,J ) , 1  ) ',
                       ['CALL', 'DCOPY', '(', 'J-1', 'R', '(', 'J', '1', ')', 'LDR', 'R', '(', '1', 'J', ')', '1', ')'],
                       '#   40       CONTINUE',
                       ['40', 'CONTINUE'],
                       '#',
                       '#         # end_if',
                       ['end_if'],
                       '#         CALL DPOTRF (  UPLO, M, R, LDR, INFO  ) ',
                       ['CALL', 'DPOTRF', '(', 'UPLO', 'M', 'R', 'LDR', 'INFO', ')'],
                       '#         IF (  INFO == 0  )  THEN',
                       ['IF', '(', 'INFO', '==', '0', ')', 'THEN'],
                       '#',
                       '#           Compute the reciprocal of the condition number of R.',
                       '#           Workspace: need 3*M.',
                       '#',
                       '#            CALL DPOCON (  UPLO, M, R, LDR, RNORM, RCOND, DWORK, IWORK,',
                       '#     $                   INFO  ) ',
                       ['CALL', 'DPOCON', '(', 'UPLO', 'M', 'R', 'LDR', 'RNORM', 'RCOND', 'DWORK', 'IWORK', 'INFO',
                        ')'],
                       '#',
                       '#           Return if the matrix is singular to working precision.',
                       '#',
                       '#            OUFACT = 1',
                       ['OUFACT', '=', '1'],
                       '#            DWORK ( 2 )  = RCOND',
                       ['DWORK', '(', '2', ')', '=', 'RCOND'],
                       '#            IF (  RCOND < EPS  )  THEN',
                       ['IF', '(', 'RCOND', '<', 'EPS', ')', 'THEN'],
                       '#               INFO = M + 1',
                       ['INFO', '=', 'M', '+', '1'],
                       '#               RETURN',
                       ['RETURN'],
                       '#            # end_if',
                       ['end_if'],
                       '#            WRKOPT = MAX (  WRKOPT, 3*M  ) ',
                       ['WRKOPT', '=', 'MAX', '(', 'WRKOPT', '3*M', ')'],
                       '#         ELSE',
                       ['ELSE'],
                       '#',
                       "#           Use UdU' or LdL' factorization, first restoring the saved",
                       '#           triangle.',
                       '#',
                       '#            CALL DCOPY (  M, DWORK, 1, R, LDR+1  ) ',
                       ['CALL', 'DCOPY', '(', 'M', 'DWORK', '1', 'R', 'LDR+1', ')'],
                       '#            IF (  LUPLOU  )  THEN',
                       ['IF', '(', 'LUPLOU', ')', 'THEN'],
                       '#',
                       '#               DO 60 J = 2, M',
                       ['DO', '60', 'J', '=', '2', 'M'],
                       '#                  CALL DCOPY (  J-1, R ( J,1 ) , LDR, R ( 1,J ) , 1  ) ',
                       ['CALL', 'DCOPY', '(', 'J-1', 'R', '(', 'J', '1', ')', 'LDR', 'R', '(', '1', 'J', ')', '1', ')'],
                       '#   60          CONTINUE',
                       ['60', 'CONTINUE'],
                       '#',
                       '#            ELSE',
                       ['ELSE'],
                       '#',
                       '#               DO 80 J = 2, M',
                       ['DO', '80', 'J', '=', '2', 'M'],
                       '#                  CALL DCOPY (  J-1, R ( 1,J ) , 1, R ( J,1 ) , LDR  ) ',
                       ['CALL', 'DCOPY', '(', 'J-1', 'R', '(', '1', 'J', ')', '1', 'R', '(', 'J', '1', ')', 'LDR', ')'],
                       '#   80          CONTINUE',
                       ['80', 'CONTINUE'],
                       '#',
                       '#            # end_if',
                       ['end_if'],
                       '#',
                       "#           Compute the UdU' or LdL' factorization.",
                       '#           Workspace: need   1,',
                       '#                      prefer M*NB.',
                       '#',
                       '#            CALL DSYTRF (  UPLO, M, R, LDR, IPIV, DWORK, LDWORK, INFO  ) ',
                       ['CALL', 'DSYTRF', '(', 'UPLO', 'M', 'R', 'LDR', 'IPIV', 'DWORK', 'LDWORK', 'INFO', ')'],
                       '#            OUFACT = 2',
                       ['OUFACT', '=', '2'],
                       '#            IF (  INFO > 0  )  THEN',
                       ['IF', '(', 'INFO', '>', '0', ')', 'THEN'],
                       '#               DWORK ( 2 )  = ONE',
                       ['DWORK', '(', '2', ')', '=', 'ONE'],
                       '#               RETURN',
                       ['RETURN'],
                       '#            # end_if',
                       ['end_if'],
                       '#            WRKOPT = MAX (  WRKOPT, INT (  DWORK ( 1 )   )   ) ',
                       ['WRKOPT', '=', 'MAX', '(', 'WRKOPT', 'INT', '(', 'DWORK', '(', '1', ')', ')', ')'],
                       '#',
                       '#           Compute the reciprocal of the condition number of R.',
                       '#           Workspace: need 2*M.',
                       '#',
                       '#            CALL DSYCON (  UPLO, M, R, LDR, IPIV, RNORM, RCOND, DWORK,',
                       '#     $                   IWORK, INFO  ) ',
                       ['CALL', 'DSYCON', '(', 'UPLO', 'M', 'R', 'LDR', 'IPIV', 'RNORM', 'RCOND', 'DWORK', 'IWORK',
                        'INFO', ')'],
                       '#',
                       '#           Return if the matrix is singular to working precision.',
                       '#',
                       '#            DWORK ( 2 )  = RCOND',
                       ['DWORK', '(', '2', ')', '=', 'RCOND'],
                       '#            IF (  RCOND < EPS  )  THEN',
                       ['IF', '(', 'RCOND', '<', 'EPS', ')', 'THEN'],
                       '#               INFO = M + 1',
                       ['INFO', '=', 'M', '+', '1'],
                       '#               RETURN',
                       ['RETURN'],
                       '#            # end_if',
                       ['end_if'],
                       '#         # end_if',
                       ['end_if'],
                       '#      # end_if',
                       ['end_if'],
                       '#',
                       '#      IF  ( OUFACT == 1  )  THEN',
                       ['IF', '(', 'OUFACT', '==', '1', ')', 'THEN'],
                       '#',
                       '#        Solve positive definite linear system(s).',
                       '#',
                       '#         IF  (  LUPLOU  )  THEN',
                       ['IF', '(', 'LUPLOU', ')', 'THEN'],
                       "#            TRANS = 'N'",
                       ['TRANS', '=', "'N'"],
                       '#         ELSE',
                       ['ELSE'],
                       "#            TRANS = 'T'",
                       ['TRANS', '=', "'T'"],
                       '#         # end_if',
                       ['end_if'],
                       '#',
                       '#        Solve the system X*U = B, overwriting B with X.',
                       '#',
                       "#         CALL DTRSM (  'Right', UPLO, TRANS, 'Non-unit', N, M,",
                       '#     $               ONE, R, LDR, B, LDB  ) ',
                       ['CALL', 'DTRSM', '(', "'Right'", 'UPLO', 'TRANS', "'Non-unit'", 'N', 'M', 'ONE', 'R', 'LDR',
                        'B', 'LDB', ')'],
                       '#',
                       '#         IF  (  LJOBG  )  THEN',
                       ['IF', '(', 'LJOBG', ')', 'THEN'],
                       '#                                      -1',
                       "#           Compute the matrix  G = B*R  *B', multiplying X*X' in G.",
                       '#',
                       "#            CALL DSYRK (  UPLO, 'No transpose', N, M, ONE, B, LDB, ZERO,",
                       '#     $                  G, LDG  ) ',
                       ['CALL', 'DSYRK', '(', 'UPLO', "'No", "transpose'", 'N', 'M', 'ONE', 'B', 'LDB', 'ZERO', 'G',
                        'LDG', ')'],
                       '#         # end_if',
                       ['end_if'],
                       '#',
                       '#         IF (  LJOBL  )  THEN',
                       ['IF', '(', 'LJOBL', ')', 'THEN'],
                       '#',
                       '#           Update matrices A and Q.',
                       '#',
                       '#           Solve the system Y*U = L, overwriting L with Y.',
                       '#',
                       "#            CALL DTRSM (  'Right', UPLO, TRANS, 'Non-unit', N, M,",
                       '#     $                  ONE, R, LDR, L, LDL  ) ',
                       ['CALL', 'DTRSM', '(', "'Right'", 'UPLO', 'TRANS', "'Non-unit'", 'N', 'M', 'ONE', 'R', 'LDR',
                        'L', 'LDL', ')'],
                       '#',
                       "#           Compute A <- A - X*Y'.",
                       '#',
                       "#            CALL DGEMM (  'No transpose', 'Transpose', N, N, M, -ONE, B,",
                       '#     $                  LDB, L, LDL, ONE, A, LDA  ) ',
                       ['CALL', 'DGEMM', '(', "'No", "transpose'", "'Transpose'", 'N', 'N', 'M', '-ONE', 'B', 'LDB',
                        'L', 'LDL', 'ONE', 'A', 'LDA', ')'],
                       '#',
                       "#           Compute Q <- Q - Y*Y'.",
                       '#',
                       "#            CALL DSYRK (  UPLO, 'No transpose', N, M, -ONE, L, LDL, ONE,",
                       '#     $                  Q, LDQ  ) ',
                       ['CALL', 'DSYRK', '(', 'UPLO', "'No", "transpose'", 'N', 'M', '-ONE', 'L', 'LDL', 'ONE', 'Q',
                        'LDQ', ')'],
                       '#         # end_if',
                       ['end_if'],
                       '#      ELSE',
                       ['ELSE'],
                       '#',
                       '#        Solve indefinite linear system(s).',
                       '#',
                       "#        Solve the system UdU'*X = B' (or LdL'*X = B').",
                       '#        Workspace: need N*M.',
                       '#',
                       '#         DO 100 J = 1, M',
                       ['DO', '100', 'J', '=', '1', 'M'],
                       '#            CALL DCOPY (  N, B ( 1,J ) , 1, DWORK ( J ) , M  ) ',
                       ['CALL', 'DCOPY', '(', 'N', 'B', '(', '1', 'J', ')', '1', 'DWORK', '(', 'J', ')', 'M', ')'],
                       '#  100    CONTINUE',
                       ['100', 'CONTINUE'],
                       '#',
                       '#         CALL DSYTRS (  UPLO, M, N, R, LDR, IPIV, DWORK, M, INFO  ) ',
                       ['CALL', 'DSYTRS', '(', 'UPLO', 'M', 'N', 'R', 'LDR', 'IPIV', 'DWORK', 'M', 'INFO', ')'],
                       '#',
                       '#         IF  (  LJOBG  )  THEN',
                       ['IF', '(', 'LJOBG', ')', 'THEN'],
                       '#                                                    -1',
                       "#           Compute a triangle of the matrix  G = B*R  *B' = B*X.",
                       '#',
                       '#            IF  (  LUPLOU  )  THEN',
                       ['IF', '(', 'LUPLOU', ')', 'THEN'],
                       '#               I = 1',
                       ['I', '=', '1'],
                       '#',
                       '#               DO 120 J = 1, N',
                       ['DO', '120', 'J', '=', '1', 'N'],
                       "#                  CALL DGEMV (  'No transpose', J, M, ONE, B, LDB,",
                       '#     $                        DWORK ( I ) , 1, ZERO, G ( 1,J ) , 1  ) ',
                       ['CALL', 'DGEMV', '(', "'No", "transpose'", 'J', 'M', 'ONE', 'B', 'LDB', 'DWORK', '(', 'I', ')',
                        '1', 'ZERO', 'G', '(', '1', 'J', ')', '1', ')'],
                       '#                  I = I + M',
                       ['I', '=', 'I', '+', 'M'],
                       '#  120          CONTINUE',
                       ['120', 'CONTINUE'],
                       '#',
                       '#            ELSE',
                       ['ELSE'],
                       '#',
                       '#               DO 140 J = 1, N',
                       ['DO', '140', 'J', '=', '1', 'N'],
                       "#                  CALL DGEMV (  'Transpose', M, J, ONE, DWORK, M, B ( J,1 ) ,",
                       '#     $                        LDB, ZERO, G ( J,1 ) , LDG  ) ',
                       ['CALL', 'DGEMV', '(', "'Transpose'", 'M', 'J', 'ONE', 'DWORK', 'M', 'B', '(', 'J', '1', ')',
                        'LDB', 'ZERO', 'G', '(', 'J', '1', ')', 'LDG', ')'],
                       '#  140          CONTINUE',
                       ['140', 'CONTINUE'],
                       '#',
                       '#            # end_if',
                       ['end_if'],
                       '#         # end_if',
                       ['end_if'],
                       '#',
                       '#         IF (  LJOBL  )  THEN',
                       ['IF', '(', 'LJOBL', ')', 'THEN'],
                       '#',
                       '#           Update matrices A and Q.',
                       '#',
                       "#           Solve the system UdU'*Y = L' (or LdL'*Y = L').",
                       '#',
                       '#            DO 160 J = 1, M',
                       ['DO', '160', 'J', '=', '1', 'M'],
                       '#               CALL DCOPY (  N, L ( 1,J ) , 1, DWORK ( J ) , M  ) ',
                       ['CALL', 'DCOPY', '(', 'N', 'L', '(', '1', 'J', ')', '1', 'DWORK', '(', 'J', ')', 'M', ')'],
                       '#  160       CONTINUE',
                       ['160', 'CONTINUE'],
                       '#',
                       '#            CALL DSYTRS (  UPLO, M, N, R, LDR, IPIV, DWORK, M, INFO  ) ',
                       ['CALL', 'DSYTRS', '(', 'UPLO', 'M', 'N', 'R', 'LDR', 'IPIV', 'DWORK', 'M', 'INFO', ')'],
                       '#',
                       '#           A <- A - B*Y.',
                       '#',
                       "#            CALL DGEMM (  'No transpose', 'No transpose', N, N, M, -ONE,",
                       '#     $                  B, LDB, DWORK, M, ONE, A, LDA  ) ',
                       ['CALL', 'DGEMM', '(', "'No", "transpose'", "'No", "transpose'", 'N', 'N', 'M', '-ONE', 'B',
                        'LDB', 'DWORK', 'M', 'ONE', 'A', 'LDA', ')'],
                       '#                                            -          -1',
                       "#           Compute a triangle of the matrix Q = Q - L*R  *L' = Q - L*Y.",
                       '#',
                       '#            IF  (  LUPLOU  )  THEN',
                       ['IF', '(', 'LUPLOU', ')', 'THEN'],
                       '#               I = 1',
                       ['I', '=', '1'],
                       '#',
                       '#               DO 180 J = 1, N',
                       ['DO', '180', 'J', '=', '1', 'N'],
                       "#                  CALL DGEMV (  'No transpose', J, M, -ONE, L, LDL,",
                       '#     $                        DWORK ( I ) , 1, ONE, Q ( 1,J ) , 1  ) ',
                       ['CALL', 'DGEMV', '(', "'No", "transpose'", 'J', 'M', '-ONE', 'L', 'LDL', 'DWORK', '(', 'I', ')',
                        '1', 'ONE', 'Q', '(', '1', 'J', ')', '1', ')'],
                       '#                  I = I + M',
                       ['I', '=', 'I', '+', 'M'],
                       '#  180          CONTINUE',
                       ['180', 'CONTINUE'],
                       '#',
                       '#            ELSE',
                       ['ELSE'],
                       '#',
                       '#               DO 200 J = 1, N',
                       ['DO', '200', 'J', '=', '1', 'N'],
                       "#                  CALL DGEMV (  'Transpose', M, J, -ONE, DWORK, M, L ( J,1 ) ,",
                       '#     $                        LDL, ONE, Q ( J,1 ) , LDQ  ) ',
                       ['CALL', 'DGEMV', '(', "'Transpose'", 'M', 'J', '-ONE', 'DWORK', 'M', 'L', '(', 'J', '1', ')',
                        'LDL', 'ONE', 'Q', '(', 'J', '1', ')', 'LDQ', ')'],
                       '#  200          CONTINUE',
                       ['200', 'CONTINUE'],
                       '#',
                       '#            # end_if',
                       ['end_if'],
                       '#         # end_if',
                       ['end_if'],
                       '#      # end_if',
                       ['end_if'],
                       '#',
                       '#      DWORK ( 1 )  = WRKOPT',
                       ['DWORK', '(', '1', ')', '=', 'WRKOPT'],
                       '#      IF  (   not LFACTA  )  DWORK ( 2 )  = RCOND',
                       ['IF', '(', 'not', 'LFACTA', ')', 'DWORK', '(', '2', ')', '=', 'RCOND'],
                       '#',
                       '# *** Last line of SB02MT ***',
                       '#      RETURN',
                       ['RETURN'],
                       '#      END',
                       ['END'],
                       ]
        expected_list = ['#      SUBROUTINE SB02MT (  JOBG, JOBL, FACT, UPLO, N, M, A, LDA, B, LDB,',
                         '#     $                   Q, LDQ, R, LDR, L, LDL, IPIV, OUFACT, G, LDG,',
                         '#     $                   IWORK, DWORK, LDWORK, INFO  ) ',
                         ['0', 'SUBROUTINE', 'SB02MT', '(', 'JOBG', 'JOBL', 'FACT', 'UPLO', 'N', 'M', 'A', 'LDA', 'B',
                          'LDB', 'Q', 'LDQ', 'R', 'LDR', 'L', 'LDL', 'IPIV', 'OUFACT', 'G', 'LDG', 'IWORK', 'DWORK',
                          'LDWORK', 'INFO', ')'],
                         '#',
                         '#     SLICOT RELEASE 5.0.',
                         '#',
                         '#     Copyright (c) 2002-2009 NICONET e.V.',
                         '#',
                         '#     This program is free software: you can redistribute it and/or',
                         '#     modify it under the terms of the GNU General Public License as',
                         '#     published by the Free Software Foundation, either version 2 of',
                         '#     the License, or (at your option) any later version.',
                         '#',
                         '#     This program is distributed in the hope that it will be useful,',
                         '#     but WITHOUT ANY WARRANTY; without even the implied warranty of',
                         '#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the',
                         '#     GNU General Public License for more details.',
                         '#',
                         '#     You should have received a copy of the GNU General Public License',
                         '#     along with this program.  If not, see',
                         '#     <http://www.gnu.org/licenses/>.',
                         '#',
                         '#     PURPOSE',
                         '#',
                         '#     To compute the following matrices',
                         '#',
                         '#                -1',
                         "#         G = B*R  *B',",
                         '#',
                         '#         -          -1',
                         "#         A = A - B*R  *L',",
                         '#',
                         '#         -          -1',
                         "#         Q = Q - L*R  *L',",
                         '#',
                         '#     where A, B, Q, R, L, and G are N-by-N, N-by-M, N-by-N, M-by-M,',
                         '#     N-by-M, and N-by-N matrices, respectively, with Q, R and G',
                         '#     symmetric matrices.',
                         '#',
                         '#     When R is well-conditioned with respect to inversion, standard',
                         '#     algorithms for solving linear-quadratic optimization problems will',
                         '#     then also solve optimization problems with coupling weighting',
                         '#     matrix L. Moreover, a gain in efficiency is possible using matrix',
                         '#     G in the deflating subspace algorithms (see SLICOT Library routine',
                         '#     SB02OD).',
                         '#',
                         '#     ARGUMENTS',
                         '#',
                         '#     Mode Parameters',
                         '#',
                         '#     JOBG    CHARACTER*1',
                         '#             Specifies whether or not the matrix G is to be computed,',
                         '#             as follows:',
                         "#             = 'G':  Compute G;",
                         "#             = 'N':  Do not compute G.",
                         '#',
                         '#     JOBL    CHARACTER*1',
                         '#             Specifies whether or not the matrix L is zero, as follows:',
                         "#             = 'Z':  L is zero;",
                         "#             = 'N':  L is nonzero.",
                         '#',
                         '#     FACT    CHARACTER*1',
                         '#             Specifies how the matrix R is given (factored or not), as',
                         '#             follows:',
                         "#             = 'N':  Array R contains the matrix R;",
                         "#             = 'C':  Array R contains the Cholesky factor of R;",
                         "#             = 'U':  Array R contains the symmetric indefinite UdU' or",
                         "#                     LdL' factorization of R.",
                         '#',
                         '#     UPLO    CHARACTER*1',
                         '#             Specifies which triangle of the matrices R and Q (if',
                         "#             JOBL = 'N') is stored, as follows:",
                         "#             = 'U':  Upper triangle is stored;",
                         "#             = 'L':  Lower triangle is stored.",
                         '#',
                         '#     Input/Output Parameters',
                         '#',
                         '#     N       (input) INTEGER',
                         '#             The order of the matrices A, Q, and G, and the number of',
                         '#             rows of the matrices B and L.  N >= 0.',
                         '#',
                         '#     M       (input) INTEGER',
                         '#             The order of the matrix R, and the number of columns of',
                         '#             the matrices B and L.  M >= 0.',
                         '#',
                         '#     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)',
                         "#             On entry, if JOBL = 'N', the leading N-by-N part of this",
                         '#             array must contain the matrix A.',
                         "#             On exit, if JOBL = 'N', and INFO = 0, the leading N-by-N",
                         '#                                                    -          -1',
                         "#             part of this array contains the matrix A = A - B*R  L'.",
                         "#             If JOBL = 'Z', this array is not referenced.",
                         '#',
                         '#     LDA     INTEGER',
                         '#             The leading dimension of array A.',
                         "#             LDA >= MAX(1,N) if JOBL = 'N';",
                         "#             LDA >= 1        if JOBL = 'Z'.",
                         '#',
                         '#     B       (input/output) DOUBLE PRECISION array, dimension (LDB,M)',
                         '#             On entry, the leading N-by-M part of this array must',
                         '#             contain the matrix B.',
                         '#             On exit, if OUFACT = 1, and INFO = 0, the leading N-by-M',
                         '#                                                             -1',
                         '#             part of this array contains the matrix B*chol(R)  .',
                         '#             On exit, B is unchanged if OUFACT = 2 (hence also when',
                         "#             FACT = 'U').",
                         '#',
                         '#     LDB     INTEGER',
                         '#             The leading dimension of array B.  LDB >= MAX(1,N).',
                         '#',
                         '#     Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)',
                         "#             On entry, if JOBL = 'N', the leading N-by-N upper",
                         "#             triangular part (if UPLO = 'U') or lower triangular part",
                         "#             (if UPLO = 'L') of this array must contain the upper",
                         '#             triangular part or lower triangular part, respectively, of',
                         '#             the symmetric matrix Q. The stricly lower triangular part',
                         "#             (if UPLO = 'U') or stricly upper triangular part (if",
                         "#             UPLO = 'L') is not referenced.",
                         "#             On exit, if JOBL = 'N' and INFO = 0, the leading N-by-N",
                         "#             upper triangular part (if UPLO = 'U') or lower triangular",
                         "#             part (if UPLO = 'L') of this array contains the upper",
                         '#             triangular part or lower triangular part, respectively, of',
                         '#                                  -          -1',
                         "#             the symmetric matrix Q = Q - L*R  *L'.",
                         "#             If JOBL = 'Z', this array is not referenced.",
                         '#',
                         '#     LDQ     INTEGER',
                         '#             The leading dimension of array Q.',
                         "#             LDQ >= MAX(1,N) if JOBL = 'N';",
                         "#             LDQ >= 1        if JOBL = 'Z'.",
                         '#',
                         '#     R       (input/output) DOUBLE PRECISION array, dimension (LDR,M)',
                         "#             On entry, if FACT = 'N', the leading M-by-M upper",
                         "#             triangular part (if UPLO = 'U') or lower triangular part",
                         "#             (if UPLO = 'L') of this array must contain the upper",
                         '#             triangular part or lower triangular part, respectively,',
                         '#             of the symmetric input weighting matrix R.',
                         "#             On entry, if FACT = 'C', the leading M-by-M upper",
                         "#             triangular part (if UPLO = 'U') or lower triangular part",
                         "#             (if UPLO = 'L') of this array must contain the Cholesky",
                         '#             factor of the positive definite input weighting matrix R',
                         '#             (as produced by LAPACK routine DPOTRF).',
                         "#             On entry, if FACT = 'U', the leading M-by-M upper",
                         "#             triangular part (if UPLO = 'U') or lower triangular part",
                         "#             (if UPLO = 'L') of this array must contain the factors of",
                         "#             the UdU' or LdL' factorization, respectively, of the",
                         '#             symmetric indefinite input weighting matrix R (as produced',
                         '#             by LAPACK routine DSYTRF).',
                         "#             If FACT = 'N', the stricly lower triangular part (if UPLO",
                         "#             = 'U') or stricly upper triangular part (if UPLO = 'L') of",
                         '#             this array is used as workspace.',
                         '#             On exit, if OUFACT = 1, and INFO = 0 (or INFO = M+1),',
                         "#             the leading M-by-M upper triangular part (if UPLO = 'U')",
                         "#             or lower triangular part (if UPLO = 'L') of this array",
                         '#             contains the Cholesky factor of the given input weighting',
                         '#             matrix.',
                         '#             On exit, if OUFACT = 2, and INFO = 0 (or INFO = M+1),',
                         "#             the leading M-by-M upper triangular part (if UPLO = 'U')",
                         "#             or lower triangular part (if UPLO = 'L') of this array",
                         "#             contains the factors of the UdU' or LdL' factorization,",
                         '#             respectively, of the given input weighting matrix.',
                         "#             On exit R is unchanged if FACT = 'C' or 'U'.",
                         '#',
                         '#     LDR     INTEGER',
                         '#             The leading dimension of array R.  LDR >= MAX(1,M).',
                         '#',
                         '#     L       (input/output) DOUBLE PRECISION array, dimension (LDL,M)',
                         "#             On entry, if JOBL = 'N', the leading N-by-M part of this",
                         '#             array must contain the matrix L.',
                         "#             On exit, if JOBL = 'N', OUFACT = 1, and INFO = 0, the",
                         '#             leading N-by-M part of this array contains the matrix',
                         '#                      -1',
                         '#             L*chol(R)  .',
                         '#             On exit, L is unchanged if OUFACT = 2 (hence also when',
                         "#             FACT = 'U').",
                         "#             L is not referenced if JOBL = 'Z'.",
                         '#',
                         '#     LDL     INTEGER',
                         '#             The leading dimension of array L.',
                         "#             LDL >= MAX(1,N) if JOBL = 'N';",
                         "#             LDL >= 1        if JOBL = 'Z'.",
                         '#',
                         '#     IPIV    (input/output) INTEGER array, dimension (M)',
                         "#             On entry, if FACT = 'U', this array must contain details",
                         '#             of the interchanges performed and the block structure of',
                         "#             the d factor in the UdU' or LdL' factorization of matrix R",
                         '#             (as produced by LAPACK routine DSYTRF).',
                         '#             On exit, if OUFACT = 2, this array contains details of',
                         '#             the interchanges performed and the block structure of the',
                         "#             d factor in the UdU' or LdL' factorization of matrix R,",
                         '#             as produced by LAPACK routine DSYTRF.',
                         "#             This array is not referenced if FACT = 'C'.",
                         '#',
                         '#     OUFACT  (output) INTEGER',
                         '#             Information about the factorization finally used.',
                         '#             OUFACT = 1:  Cholesky factorization of R has been used;',
                         "#             OUFACT = 2:  UdU' (if UPLO = 'U') or LdL' (if UPLO = 'L')",
                         '#                          factorization of R has been used.',
                         '#',
                         '#     G       (output) DOUBLE PRECISION array, dimension (LDG,N)',
                         "#             If JOBG = 'G', and INFO = 0, the leading N-by-N upper",
                         "#             triangular part (if UPLO = 'U') or lower triangular part",
                         "#             (if UPLO = 'L') of this array contains the upper",
                         "#             triangular part (if UPLO = 'U') or lower triangular part",
                         '#                                                                 -1',
                         "#             (if UPLO = 'L'), respectively, of the matrix G = B*R  B'.",
                         "#             If JOBG = 'N', this array is not referenced.",
                         '#',
                         '#     LDG     INTEGER',
                         '#             The leading dimension of array G.',
                         "#             LDG >= MAX(1,N) if JOBG = 'G',",
                         "#             LDG >= 1        if JOBG = 'N'.",
                         '#',
                         '#     Workspace',
                         '#',
                         '#     IWORK   INTEGER array, dimension (M)',
                         '#',
                         '#     DWORK   DOUBLE PRECISION array, dimension (LDWORK)',
                         '#             On exit, if INFO = 0, DWORK(1) returns the optimal value',
                         "#             of LDWORK; if FACT = 'N', DWORK(2) contains the reciprocal",
                         '#             condition number of the given matrix R.',
                         '#',
                         '#     LDWORK  INTEGER',
                         '#             The length of the array DWORK.',
                         "#             LDWORK >= 1              if FACT = 'C';",
                         "#             LDWORK >= MAX(2,3*M,N*M) if FACT = 'N';",
                         "#             LDWORK >= MAX(1,N*M)     if FACT = 'U'.",
                         '#             For optimum performance LDWORK should be larger than 3*M,',
                         "#             if FACT = 'N'.",
                         "#             The N*M workspace is not needed for FACT = 'N', if matrix",
                         '#             R is positive definite.',
                         '#',
                         '#     Error Indicator',
                         '#',
                         '#     INFO    INTEGER',
                         '#             = 0:  successful exit;',
                         '#             < 0:  if INFO = -i, the i-th argument had an illegal',
                         '#                   value;',
                         '#             = i:  if the i-th element (1 <= i <= M) of the d factor is',
                         "#                   exactly zero; the UdU' (or LdL') factorization has",
                         '#                   been completed, but the block diagonal matrix d is',
                         '#                   exactly singular;',
                         '#             = M+1:  if the matrix R is numerically singular.',
                         '#',
                         '#     METHOD',
                         '#                            -     -',
                         '#     The matrices G, and/or A and Q are evaluated using the given or',
                         '#     computed symmetric factorization of R.',
                         '#',
                         '#     NUMERICAL ASPECTS',
                         '#',
                         '#     The routine should not be used when R is ill-conditioned.',
                         '#',
                         '#     CONTRIBUTOR',
                         '#',
                         '#     Release 3.0: V. Sima, Katholieke Univ. Leuven, Belgium, Sep. 1997.',
                         '#',
                         '#     REVISIONS',
                         '#',
                         '#     -',
                         '#',
                         '#     KEYWORDS',
                         '#',
                         '#     Algebraic Riccati equation, closed loop system, continuous-time',
                         '#     system, discrete-time system, optimal regulator, Schur form.',
                         '#',
                         '#     ******************************************************************',
                         '#""',
                         '#',
                         '#     .. Parameters ..',
                         '#      DOUBLE PRECISION  ZERO, ONE',
                         ['   1', 'DOUBLE', 'PRECISION', 'ZERO', 'ONE'],
                         '#      PARAMETER          (  ZERO = 0.0D0, ONE = 1.0D0  ) ',
                         ['   1', 'PARAMETER', '(', 'ZERO', '=', '0.0D0', 'ONE', '=', '1.0D0', ')'],
                         '#     .. Scalar Arguments ..',
                         '#      CHARACTER         FACT, JOBG, JOBL, UPLO',
                         ['   1', 'CHARACTER', 'FACT', 'JOBG', 'JOBL', 'UPLO'],
                         '#      INTEGER           INFO, LDA, LDB, LDG, LDL, LDQ, LDR, LDWORK, M,',
                         '#     $                  N, OUFACT',
                         ['   1', 'INTEGER', 'INFO', 'LDA', 'LDB', 'LDG', 'LDL', 'LDQ', 'LDR', 'LDWORK', 'M', 'N',
                          'OUFACT'],
                         '#     .. Array Arguments ..',
                         '#      INTEGER           IPIV ( * ) , IWORK ( * ) ',
                         ['   1', 'INTEGER', 'IPIV', '(', '*', ')', 'IWORK', '(', '*', ')'],
                         '#      DOUBLE PRECISION  A ( LDA,* ) , B ( LDB,* ) , DWORK ( * ) , G ( LDG,* ) ,',
                         '#     $                  L ( LDL,* ) , Q ( LDQ,* ) , R ( LDR,* ) ',
                         ['   1', 'DOUBLE', 'PRECISION', 'A', '(', 'LDA', '*', ')', 'B', '(', 'LDB', '*', ')', 'DWORK',
                          '(', '*', ')', 'G', '(', 'LDG', '*', ')', 'L', '(', 'LDL', '*', ')', 'Q', '(', 'LDQ', '*',
                          ')', 'R', '(', 'LDR', '*', ')'],
                         '#     .. Local Scalars ..',
                         '#      LOGICAL           LFACTA, LFACTC, LFACTU, LJOBG, LJOBL, LUPLOU',
                         ['   1', 'LOGICAL', 'LFACTA', 'LFACTC', 'LFACTU', 'LJOBG', 'LJOBL', 'LUPLOU'],
                         '#      CHARACTER         TRANS',
                         ['   1', 'CHARACTER', 'TRANS'],
                         '#      INTEGER           I, J, WRKOPT',
                         ['   1', 'INTEGER', 'I', 'J', 'WRKOPT'],
                         '#      DOUBLE PRECISION  EPS, RCOND, RNORM',
                         ['   1', 'DOUBLE', 'PRECISION', 'EPS', 'RCOND', 'RNORM'],
                         '#     .. External Functions ..',
                         '#      LOGICAL           LSAME',
                         ['   1', 'LOGICAL', 'LSAME'],
                         '#      DOUBLE PRECISION  DLAMCH, DLANSY',
                         ['   1', 'DOUBLE', 'PRECISION', 'DLAMCH', 'DLANSY'],
                         '#      EXTERNAL          DLAMCH, DLANSY, LSAME',
                         ['   1', 'EXTERNAL', 'DLAMCH', 'DLANSY', 'LSAME'],
                         '#     .. External Subroutines ..',
                         '#      EXTERNAL          DCOPY, DGEMM, DGEMV, DPOCON, DPOTRF, DSYCON,',
                         '#     $                  DSYRK, DSYTRF, DSYTRS, DTRSM, XERBLA',
                         ['   1', 'EXTERNAL', 'DCOPY', 'DGEMM', 'DGEMV', 'DPOCON', 'DPOTRF', 'DSYCON', 'DSYRK',
                          'DSYTRF', 'DSYTRS', 'DTRSM', 'XERBLA'],
                         '#     .. Intrinsic Functions ..',
                         '#      INTRINSIC         INT, MAX',
                         ['   1', 'INTRINSIC', 'INT', 'MAX'],
                         '#     .. Executable Statements ..',
                         '#',
                         '#      INFO   = 0',
                         ['   1', 'INFO', '=', '0'],
                         "#      LJOBG  = LSAME (  JOBG, 'G'  ) ",
                         ['   1', 'LJOBG', '=', 'LSAME', '(', 'JOBG', "'G'", ')'],
                         "#      LJOBL  = LSAME (  JOBL, 'N'  ) ",
                         ['   1', 'LJOBL', '=', 'LSAME', '(', 'JOBL', "'N'", ')'],
                         "#      LFACTC = LSAME (  FACT, 'C'  ) ",
                         ['   1', 'LFACTC', '=', 'LSAME', '(', 'FACT', "'C'", ')'],
                         "#      LFACTU = LSAME (  FACT, 'U'  ) ",
                         ['   1', 'LFACTU', '=', 'LSAME', '(', 'FACT', "'U'", ')'],
                         "#      LUPLOU = LSAME (  UPLO, 'U'  ) ",
                         ['   1', 'LUPLOU', '=', 'LSAME', '(', 'UPLO', "'U'", ')'],
                         '#      LFACTA = LFACTC or LFACTU',
                         ['   1', 'LFACTA', '=', 'LFACTC', 'or', 'LFACTU'],
                         '#',
                         '#     Test the input scalar arguments.',
                         '#',
                         "#      IF (   not LJOBG  and   not LSAME (  JOBG, 'N'  )   )  THEN",
                         ['   1', 'IF', '(', 'not', 'LJOBG', 'and', 'not', 'LSAME', '(', 'JOBG', "'N'", ')', ')',
                          'THEN'],
                         '#         INFO = -1',
                         ['       2', 'INFO', '=', '-1'],
                         "#      elif (   not LJOBL  and   not LSAME (  JOBL, 'Z'  )   )  THEN",
                         ['   1', 'elif', '(', 'not', 'LJOBL', 'and', 'not', 'LSAME', '(', 'JOBL', "'Z'", ')', ')',
                          'THEN'],
                         '#         INFO = -2',
                         ['       2', 'INFO', '=', '-2'],
                         "#      elif (   not LFACTA  and   not LSAME (  FACT, 'N'  )   )  THEN",
                         ['   1', 'elif', '(', 'not', 'LFACTA', 'and', 'not', 'LSAME', '(', 'FACT', "'N'", ')', ')',
                          'THEN'],
                         '#         INFO = -3',
                         ['       2', 'INFO', '=', '-3'],
                         "#      elif (   not LUPLOU  and   not LSAME (  UPLO, 'L'  )   )  THEN",
                         ['   1', 'elif', '(', 'not', 'LUPLOU', 'and', 'not', 'LSAME', '(', 'UPLO', "'L'", ')', ')',
                          'THEN'],
                         '#         INFO = -4',
                         ['       2', 'INFO', '=', '-4'],
                         '#      elif (  N < 0  )  THEN',
                         ['   1', 'elif', '(', 'N', '<', '0', ')', 'THEN'],
                         '#         INFO = -5',
                         ['       2', 'INFO', '=', '-5'],
                         '#      elif (  M < 0  )  THEN',
                         ['   1', 'elif', '(', 'M', '<', '0', ')', 'THEN'],
                         '#         INFO = -6',
                         ['       2', 'INFO', '=', '-6'],
                         '#      elif (   (  LDA < 1  )   or   (  LJOBL  and  LDA < N  )   )  THEN',
                         ['   1', 'elif', '(', '(', 'LDA', '<', '1', ')', 'or', '(', 'LJOBL', 'and', 'LDA', '<', 'N',
                          ')', ')', 'THEN'],
                         '#         INFO = -8',
                         ['       2', 'INFO', '=', '-8'],
                         '#      elif (  LDB < MAX (  1, N  )   )  THEN',
                         ['   1', 'elif', '(', 'LDB', '<', 'MAX', '(', '1', 'N', ')', ')', 'THEN'],
                         '#         INFO = -10',
                         ['       2', 'INFO', '=', '-10'],
                         '#      elif (   (  LDQ < 1  )   or   (  LJOBL  and  LDQ < N  )   )  THEN',
                         ['   1', 'elif', '(', '(', 'LDQ', '<', '1', ')', 'or', '(', 'LJOBL', 'and', 'LDQ', '<', 'N',
                          ')', ')', 'THEN'],
                         '#         INFO = -12',
                         ['       2', 'INFO', '=', '-12'],
                         '#      elif (  LDR < MAX (  1, M  )   )  THEN',
                         ['   1', 'elif', '(', 'LDR', '<', 'MAX', '(', '1', 'M', ')', ')', 'THEN'],
                         '#         INFO = -14',
                         ['       2', 'INFO', '=', '-14'],
                         '#      elif (   (  LDL < 1  )   or   (  LJOBL  and  LDL < N  )   )  THEN',
                         ['   1', 'elif', '(', '(', 'LDL', '<', '1', ')', 'or', '(', 'LJOBL', 'and', 'LDL', '<', 'N',
                          ')', ')', 'THEN'],
                         '#         INFO = -16',
                         ['       2', 'INFO', '=', '-16'],
                         '#      elif (   (  LDG < 1  )   or   (  LJOBG  and  LDG < N  )   )  THEN',
                         ['   1', 'elif', '(', '(', 'LDG', '<', '1', ')', 'or', '(', 'LJOBG', 'and', 'LDG', '<', 'N',
                          ')', ')', 'THEN'],
                         '#         INFO = -20',
                         ['       2', 'INFO', '=', '-20'],
                         '#      elif (   (  LFACTC  and  LDWORK < 1  )   or ',
                         '#     $          (  LFACTU  and  LDWORK < MAX (  1, N*M  )   )   or ',
                         '#     $     (   not LFACTA  and  LDWORK < MAX (  2, N*M, 3*M  )   )   )  THEN',
                         ['   1', 'elif', '(', '(', 'LFACTC', 'and', 'LDWORK', '<', '1', ')', 'or', '(', 'LFACTU',
                          'and', 'LDWORK', '<', 'MAX', '(', '1', 'N*M', ')', ')', 'or', '(', 'not', 'LFACTA', 'and',
                          'LDWORK', '<', 'MAX', '(', '2', 'N*M', '3*M', ')', ')', ')', 'THEN'],
                         '#         INFO = -23',
                         ['       2', 'INFO', '=', '-23'],
                         '#      # end_if',
                         ['   1', 'end_if'],
                         '#',
                         '#      IF  (  INFO != 0  )  THEN',
                         ['   1', 'IF', '(', 'INFO', '!=', '0', ')', 'THEN'],
                         '#',
                         '#        Error return.',
                         '#',
                         "#         CALL XERBLA (  'sb02mt', -INFO  ) ",
                         ['       2', 'CALL', 'XERBLA', '(', "'sb02mt'", '-INFO', ')'],
                         '#         RETURN',
                         ['       2', 'RETURN'],
                         '#      # end_if',
                         ['   1', 'end_if'],
                         '#',
                         '#      IF  (  LFACTC  )  THEN',
                         ['   1', 'IF', '(', 'LFACTC', ')', 'THEN'],
                         '#         OUFACT = 1',
                         ['       2', 'OUFACT', '=', '1'],
                         '#      elif  (  LFACTU  )  THEN',
                         ['   1', 'elif', '(', 'LFACTU', ')', 'THEN'],
                         '#         OUFACT = 2',
                         ['       2', 'OUFACT', '=', '2'],
                         '#      # end_if',
                         ['   1', 'end_if'],
                         '#',
                         '#     Quick return if possible.',
                         '#',
                         '#      IF  (  N == 0  or  M == 0  or   not  (  LJOBL or LJOBG  )   )  THEN',
                         ['   1', 'IF', '(', 'N', '==', '0', 'or', 'M', '==', '0', 'or', 'not', '(', 'LJOBL', 'or',
                          'LJOBG', ')', ')', 'THEN'],
                         '#        DWORK ( 1 )  = ONE',
                         ['       2', 'DWORK', '(', '1', ')', '=', 'ONE'],
                         '#        IF  (   not LFACTA  )  DWORK ( 2 )  = ONE',
                         ['       2', 'IF', '(', 'not', 'LFACTA', ')', 'DWORK', '(', '2', ')', '=', 'ONE'],
                         '#        RETURN',
                         ['       2', 'RETURN'],
                         '#      # end_if',
                         ['   1', 'end_if'],
                         '#',
                         '#     (Note: Comments in the code beginning "Workspace:" describe the',
                         '#     minimal amount of workspace needed at that point in the code,',
                         '#     as well as the preferred amount for good performance.',
                         '#     NB refers to the optimal block size for the immediately',
                         '#     following subroutine, as returned by ILAENV.)',
                         '#',
                         '#      WRKOPT = 1',
                         ['   1', 'WRKOPT', '=', '1'],
                         '#',
                         '#     Set relative machine precision.',
                         '#',
                         "#      EPS = DLAMCH (  'Epsilon'  ) ",
                         ['   1', 'EPS', '=', 'DLAMCH', '(', "'Epsilon'", ')'],
                         '#',
                         '#      IF  (   not LFACTA  )  THEN',
                         ['   1', 'IF', '(', 'not', 'LFACTA', ')', 'THEN'],
                         '#',
                         '#        Compute the norm of the matrix R, which is not factored.',
                         '#        Then save the given triangle of R in the other strict triangle',
                         '#        and the diagonal in the workspace, and try Cholesky',
                         '#        factorization.',
                         '#        Workspace: need M.',
                         '#',
                         "#         RNORM = DLANSY (  '1-norm', UPLO, M, R, LDR, DWORK  ) ",
                         ['       2', 'RNORM', '=', 'DLANSY', '(', "'1-norm'", 'UPLO', 'M', 'R', 'LDR', 'DWORK', ')'],
                         '#         CALL DCOPY (  M, R, LDR+1, DWORK, 1  ) ',
                         ['       2', 'CALL', 'DCOPY', '(', 'M', 'R', 'LDR+1', 'DWORK', '1', ')'],
                         '#         IF (  LUPLOU  )  THEN',
                         ['       2', 'IF', '(', 'LUPLOU', ')', 'THEN'],
                         '#',
                         '#            DO 20 J = 2, M',
                         ['           3', 'DO', '20', 'J', '=', '2', 'M'],
                         '#               CALL DCOPY (  J-1, R ( 1,J ) , 1, R ( J,1 ) , LDR  ) ',
                         ['               4', 'CALL', 'DCOPY', '(', 'J-1', 'R', '(', '1', 'J', ')', '1', 'R', '(', 'J',
                          '1', ')', 'LDR', ')'],
                         '#   20       CONTINUE',
                         ['           3', '20', 'CONTINUE'],
                         '#',
                         '#         ELSE',
                         ['       2', 'ELSE'],
                         '#',
                         '#            DO 40 J = 2, M',
                         ['           3', 'DO', '40', 'J', '=', '2', 'M'],
                         '#               CALL DCOPY (  J-1, R ( J,1 ) , LDR, R ( 1,J ) , 1  ) ',
                         ['               4', 'CALL', 'DCOPY', '(', 'J-1', 'R', '(', 'J', '1', ')', 'LDR', 'R', '(',
                          '1', 'J', ')', '1', ')'],
                         '#   40       CONTINUE',
                         ['           3', '40', 'CONTINUE'],
                         '#',
                         '#         # end_if',
                         ['       2', 'end_if'],
                         '#         CALL DPOTRF (  UPLO, M, R, LDR, INFO  ) ',
                         ['       2', 'CALL', 'DPOTRF', '(', 'UPLO', 'M', 'R', 'LDR', 'INFO', ')'],
                         '#         IF (  INFO == 0  )  THEN',
                         ['       2', 'IF', '(', 'INFO', '==', '0', ')', 'THEN'],
                         '#',
                         '#           Compute the reciprocal of the condition number of R.',
                         '#           Workspace: need 3*M.',
                         '#',
                         '#            CALL DPOCON (  UPLO, M, R, LDR, RNORM, RCOND, DWORK, IWORK,',
                         '#     $                   INFO  ) ',
                         ['           3', 'CALL', 'DPOCON', '(', 'UPLO', 'M', 'R', 'LDR', 'RNORM', 'RCOND', 'DWORK',
                          'IWORK', 'INFO', ')'],
                         '#',
                         '#           Return if the matrix is singular to working precision.',
                         '#',
                         '#            OUFACT = 1',
                         ['           3', 'OUFACT', '=', '1'],
                         '#            DWORK ( 2 )  = RCOND',
                         ['           3', 'DWORK', '(', '2', ')', '=', 'RCOND'],
                         '#            IF (  RCOND < EPS  )  THEN',
                         ['           3', 'IF', '(', 'RCOND', '<', 'EPS', ')', 'THEN'],
                         '#               INFO = M + 1',
                         ['               4', 'INFO', '=', 'M', '+', '1'],
                         '#               RETURN',
                         ['               4', 'RETURN'],
                         '#            # end_if',
                         ['           3', 'end_if'],
                         '#            WRKOPT = MAX (  WRKOPT, 3*M  ) ',
                         ['           3', 'WRKOPT', '=', 'MAX', '(', 'WRKOPT', '3*M', ')'],
                         '#         ELSE',
                         ['       2', 'ELSE'],
                         '#',
                         "#           Use UdU' or LdL' factorization, first restoring the saved",
                         '#           triangle.',
                         '#',
                         '#            CALL DCOPY (  M, DWORK, 1, R, LDR+1  ) ',
                         ['           3', 'CALL', 'DCOPY', '(', 'M', 'DWORK', '1', 'R', 'LDR+1', ')'],
                         '#            IF (  LUPLOU  )  THEN',
                         ['           3', 'IF', '(', 'LUPLOU', ')', 'THEN'],
                         '#',
                         '#               DO 60 J = 2, M',
                         ['               4', 'DO', '60', 'J', '=', '2', 'M'],
                         '#                  CALL DCOPY (  J-1, R ( J,1 ) , LDR, R ( 1,J ) , 1  ) ',
                         ['                   5', 'CALL', 'DCOPY', '(', 'J-1', 'R', '(', 'J', '1', ')', 'LDR', 'R', '(',
                          '1', 'J', ')', '1', ')'],
                         '#   60          CONTINUE',
                         ['               4', '60', 'CONTINUE'],
                         '#',
                         '#            ELSE',
                         ['           3', 'ELSE'],
                         '#',
                         '#               DO 80 J = 2, M',
                         ['               4', 'DO', '80', 'J', '=', '2', 'M'],
                         '#                  CALL DCOPY (  J-1, R ( 1,J ) , 1, R ( J,1 ) , LDR  ) ',
                         ['                   5', 'CALL', 'DCOPY', '(', 'J-1', 'R', '(', '1', 'J', ')', '1', 'R', '(',
                          'J', '1', ')', 'LDR', ')'],
                         '#   80          CONTINUE',
                         ['               4', '80', 'CONTINUE'],
                         '#',
                         '#            # end_if',
                         ['           3', 'end_if'],
                         '#',
                         "#           Compute the UdU' or LdL' factorization.",
                         '#           Workspace: need   1,',
                         '#                      prefer M*NB.',
                         '#',
                         '#            CALL DSYTRF (  UPLO, M, R, LDR, IPIV, DWORK, LDWORK, INFO  ) ',
                         ['           3', 'CALL', 'DSYTRF', '(', 'UPLO', 'M', 'R', 'LDR', 'IPIV', 'DWORK', 'LDWORK',
                          'INFO', ')'],
                         '#            OUFACT = 2',
                         ['           3', 'OUFACT', '=', '2'],
                         '#            IF (  INFO > 0  )  THEN',
                         ['           3', 'IF', '(', 'INFO', '>', '0', ')', 'THEN'],
                         '#               DWORK ( 2 )  = ONE',
                         ['               4', 'DWORK', '(', '2', ')', '=', 'ONE'],
                         '#               RETURN',
                         ['               4', 'RETURN'],
                         '#            # end_if',
                         ['           3', 'end_if'],
                         '#            WRKOPT = MAX (  WRKOPT, INT (  DWORK ( 1 )   )   ) ',
                         ['           3', 'WRKOPT', '=', 'MAX', '(', 'WRKOPT', 'INT', '(', 'DWORK', '(', '1', ')', ')',
                          ')'],
                         '#',
                         '#           Compute the reciprocal of the condition number of R.',
                         '#           Workspace: need 2*M.',
                         '#',
                         '#            CALL DSYCON (  UPLO, M, R, LDR, IPIV, RNORM, RCOND, DWORK,',
                         '#     $                   IWORK, INFO  ) ',
                         ['           3', 'CALL', 'DSYCON', '(', 'UPLO', 'M', 'R', 'LDR', 'IPIV', 'RNORM', 'RCOND',
                          'DWORK', 'IWORK', 'INFO', ')'],
                         '#',
                         '#           Return if the matrix is singular to working precision.',
                         '#',
                         '#            DWORK ( 2 )  = RCOND',
                         ['           3', 'DWORK', '(', '2', ')', '=', 'RCOND'],
                         '#            IF (  RCOND < EPS  )  THEN',
                         ['           3', 'IF', '(', 'RCOND', '<', 'EPS', ')', 'THEN'],
                         '#               INFO = M + 1',
                         ['               4', 'INFO', '=', 'M', '+', '1'],
                         '#               RETURN',
                         ['               4', 'RETURN'],
                         '#            # end_if',
                         ['           3', 'end_if'],
                         '#         # end_if',
                         ['       2', 'end_if'],
                         '#      # end_if',
                         ['   1', 'end_if'],
                         '#',
                         '#      IF  ( OUFACT == 1  )  THEN',
                         ['   1', 'IF', '(', 'OUFACT', '==', '1', ')', 'THEN'],
                         '#',
                         '#        Solve positive definite linear system(s).',
                         '#',
                         '#         IF  (  LUPLOU  )  THEN',
                         ['       2', 'IF', '(', 'LUPLOU', ')', 'THEN'],
                         "#            TRANS = 'N'",
                         ['           3', 'TRANS', '=', "'N'"],
                         '#         ELSE',
                         ['       2', 'ELSE'],
                         "#            TRANS = 'T'",
                         ['           3', 'TRANS', '=', "'T'"],
                         '#         # end_if',
                         ['       2', 'end_if'],
                         '#',
                         '#        Solve the system X*U = B, overwriting B with X.',
                         '#',
                         "#         CALL DTRSM (  'Right', UPLO, TRANS, 'Non-unit', N, M,",
                         '#     $               ONE, R, LDR, B, LDB  ) ',
                         ['       2', 'CALL', 'DTRSM', '(', "'Right'", 'UPLO', 'TRANS', "'Non-unit'", 'N', 'M', 'ONE',
                          'R', 'LDR', 'B', 'LDB', ')'],
                         '#',
                         '#         IF  (  LJOBG  )  THEN',
                         ['       2', 'IF', '(', 'LJOBG', ')', 'THEN'],
                         '#                                      -1',
                         "#           Compute the matrix  G = B*R  *B', multiplying X*X' in G.",
                         '#',
                         "#            CALL DSYRK (  UPLO, 'No transpose', N, M, ONE, B, LDB, ZERO,",
                         '#     $                  G, LDG  ) ',
                         ['           3', 'CALL', 'DSYRK', '(', 'UPLO', "'No", "transpose'", 'N', 'M', 'ONE', 'B',
                          'LDB', 'ZERO', 'G', 'LDG', ')'],
                         '#         # end_if',
                         ['       2', 'end_if'],
                         '#',
                         '#         IF (  LJOBL  )  THEN',
                         ['       2', 'IF', '(', 'LJOBL', ')', 'THEN'],
                         '#',
                         '#           Update matrices A and Q.',
                         '#',
                         '#           Solve the system Y*U = L, overwriting L with Y.',
                         '#',
                         "#            CALL DTRSM (  'Right', UPLO, TRANS, 'Non-unit', N, M,",
                         '#     $                  ONE, R, LDR, L, LDL  ) ',
                         ['           3', 'CALL', 'DTRSM', '(', "'Right'", 'UPLO', 'TRANS', "'Non-unit'", 'N', 'M',
                          'ONE', 'R', 'LDR', 'L', 'LDL', ')'],
                         '#',
                         "#           Compute A <- A - X*Y'.",
                         '#',
                         "#            CALL DGEMM (  'No transpose', 'Transpose', N, N, M, -ONE, B,",
                         '#     $                  LDB, L, LDL, ONE, A, LDA  ) ',
                         ['           3', 'CALL', 'DGEMM', '(', "'No", "transpose'", "'Transpose'", 'N', 'N', 'M',
                          '-ONE', 'B', 'LDB', 'L', 'LDL', 'ONE', 'A', 'LDA', ')'],
                         '#',
                         "#           Compute Q <- Q - Y*Y'.",
                         '#',
                         "#            CALL DSYRK (  UPLO, 'No transpose', N, M, -ONE, L, LDL, ONE,",
                         '#     $                  Q, LDQ  ) ',
                         ['           3', 'CALL', 'DSYRK', '(', 'UPLO', "'No", "transpose'", 'N', 'M', '-ONE', 'L',
                          'LDL', 'ONE', 'Q', 'LDQ', ')'],
                         '#         # end_if',
                         ['       2', 'end_if'],
                         '#      ELSE',
                         ['   1', 'ELSE'],
                         '#',
                         '#        Solve indefinite linear system(s).',
                         '#',
                         "#        Solve the system UdU'*X = B' (or LdL'*X = B').",
                         '#        Workspace: need N*M.',
                         '#',
                         '#         DO 100 J = 1, M',
                         ['       2', 'DO', '100', 'J', '=', '1', 'M'],
                         '#            CALL DCOPY (  N, B ( 1,J ) , 1, DWORK ( J ) , M  ) ',
                         ['           3', 'CALL', 'DCOPY', '(', 'N', 'B', '(', '1', 'J', ')', '1', 'DWORK', '(', 'J',
                          ')', 'M', ')'],
                         '#  100    CONTINUE',
                         ['       2', '100', 'CONTINUE'],
                         '#',
                         '#         CALL DSYTRS (  UPLO, M, N, R, LDR, IPIV, DWORK, M, INFO  ) ',
                         ['       2', 'CALL', 'DSYTRS', '(', 'UPLO', 'M', 'N', 'R', 'LDR', 'IPIV', 'DWORK', 'M', 'INFO',
                          ')'],
                         '#',
                         '#         IF  (  LJOBG  )  THEN',
                         ['       2', 'IF', '(', 'LJOBG', ')', 'THEN'],
                         '#                                                    -1',
                         "#           Compute a triangle of the matrix  G = B*R  *B' = B*X.",
                         '#',
                         '#            IF  (  LUPLOU  )  THEN',
                         ['           3', 'IF', '(', 'LUPLOU', ')', 'THEN'],
                         '#               I = 1',
                         ['               4', 'I', '=', '1'],
                         '#',
                         '#               DO 120 J = 1, N',
                         ['               4', 'DO', '120', 'J', '=', '1', 'N'],
                         "#                  CALL DGEMV (  'No transpose', J, M, ONE, B, LDB,",
                         '#     $                        DWORK ( I ) , 1, ZERO, G ( 1,J ) , 1  ) ',
                         ['                   5', 'CALL', 'DGEMV', '(', "'No", "transpose'", 'J', 'M', 'ONE', 'B',
                          'LDB', 'DWORK', '(', 'I', ')', '1', 'ZERO', 'G', '(', '1', 'J', ')', '1', ')'],
                         '#                  I = I + M',
                         ['                   5', 'I', '=', 'I', '+', 'M'],
                         '#  120          CONTINUE',
                         ['               4', '120', 'CONTINUE'],
                         '#',
                         '#            ELSE',
                         ['           3', 'ELSE'],
                         '#',
                         '#               DO 140 J = 1, N',
                         ['               4', 'DO', '140', 'J', '=', '1', 'N'],
                         "#                  CALL DGEMV (  'Transpose', M, J, ONE, DWORK, M, B ( J,1 ) ,",
                         '#     $                        LDB, ZERO, G ( J,1 ) , LDG  ) ',
                         ['                   5', 'CALL', 'DGEMV', '(', "'Transpose'", 'M', 'J', 'ONE', 'DWORK', 'M',
                          'B', '(', 'J', '1', ')', 'LDB', 'ZERO', 'G', '(', 'J', '1', ')', 'LDG', ')'],
                         '#  140          CONTINUE',
                         ['               4', '140', 'CONTINUE'],
                         '#',
                         '#            # end_if',
                         ['           3', 'end_if'],
                         '#         # end_if',
                         ['       2', 'end_if'],
                         '#',
                         '#         IF (  LJOBL  )  THEN',
                         ['       2', 'IF', '(', 'LJOBL', ')', 'THEN'],
                         '#',
                         '#           Update matrices A and Q.',
                         '#',
                         "#           Solve the system UdU'*Y = L' (or LdL'*Y = L').",
                         '#',
                         '#            DO 160 J = 1, M',
                         ['           3', 'DO', '160', 'J', '=', '1', 'M'],
                         '#               CALL DCOPY (  N, L ( 1,J ) , 1, DWORK ( J ) , M  ) ',
                         ['               4', 'CALL', 'DCOPY', '(', 'N', 'L', '(', '1', 'J', ')', '1', 'DWORK', '(',
                          'J', ')', 'M', ')'],
                         '#  160       CONTINUE',
                         ['           3', '160', 'CONTINUE'],
                         '#',
                         '#            CALL DSYTRS (  UPLO, M, N, R, LDR, IPIV, DWORK, M, INFO  ) ',
                         ['           3', 'CALL', 'DSYTRS', '(', 'UPLO', 'M', 'N', 'R', 'LDR', 'IPIV', 'DWORK', 'M',
                          'INFO', ')'],
                         '#',
                         '#           A <- A - B*Y.',
                         '#',
                         "#            CALL DGEMM (  'No transpose', 'No transpose', N, N, M, -ONE,",
                         '#     $                  B, LDB, DWORK, M, ONE, A, LDA  ) ',
                         ['           3', 'CALL', 'DGEMM', '(', "'No", "transpose'", "'No", "transpose'", 'N', 'N', 'M',
                          '-ONE', 'B', 'LDB', 'DWORK', 'M', 'ONE', 'A', 'LDA', ')'],
                         '#                                            -          -1',
                         "#           Compute a triangle of the matrix Q = Q - L*R  *L' = Q - L*Y.",
                         '#',
                         '#            IF  (  LUPLOU  )  THEN',
                         ['           3', 'IF', '(', 'LUPLOU', ')', 'THEN'],
                         '#               I = 1',
                         ['               4', 'I', '=', '1'],
                         '#',
                         '#               DO 180 J = 1, N',
                         ['               4', 'DO', '180', 'J', '=', '1', 'N'],
                         "#                  CALL DGEMV (  'No transpose', J, M, -ONE, L, LDL,",
                         '#     $                        DWORK ( I ) , 1, ONE, Q ( 1,J ) , 1  ) ',
                         ['                   5', 'CALL', 'DGEMV', '(', "'No", "transpose'", 'J', 'M', '-ONE', 'L',
                          'LDL', 'DWORK', '(', 'I', ')', '1', 'ONE', 'Q', '(', '1', 'J', ')', '1', ')'],
                         '#                  I = I + M',
                         ['                   5', 'I', '=', 'I', '+', 'M'],
                         '#  180          CONTINUE',
                         ['               4', '180', 'CONTINUE'],
                         '#',
                         '#            ELSE',
                         ['           3', 'ELSE'],
                         '#',
                         '#               DO 200 J = 1, N',
                         ['               4', 'DO', '200', 'J', '=', '1', 'N'],
                         "#                  CALL DGEMV (  'Transpose', M, J, -ONE, DWORK, M, L ( J,1 ) ,",
                         '#     $                        LDL, ONE, Q ( J,1 ) , LDQ  ) ',
                         ['                   5', 'CALL', 'DGEMV', '(', "'Transpose'", 'M', 'J', '-ONE', 'DWORK', 'M',
                          'L', '(', 'J', '1', ')', 'LDL', 'ONE', 'Q', '(', 'J', '1', ')', 'LDQ', ')'],
                         '#  200          CONTINUE',
                         ['               4', '200', 'CONTINUE'],
                         '#',
                         '#            # end_if',
                         ['           3', 'end_if'],
                         '#         # end_if',
                         ['       2', 'end_if'],
                         '#      # end_if',
                         ['   1', 'end_if'],
                         '#',
                         '#      DWORK ( 1 )  = WRKOPT',
                         ['   1', 'DWORK', '(', '1', ')', '=', 'WRKOPT'],
                         '#      IF  (   not LFACTA  )  DWORK ( 2 )  = RCOND',
                         ['   1', 'IF', '(', 'not', 'LFACTA', ')', 'DWORK', '(', '2', ')', '=', 'RCOND'],
                         '#',
                         '# *** Last line of SB02MT ***',
                         '#      RETURN',
                         ['   1', 'RETURN'],
                         '#      END',
                         ['   1', 'END'],
                         ]

        f2pe.decide_indent_level(python_list)

        self.assertSequenceEqual(expected_list, python_list)

    def test_replace_loop_sep(self):
        input_src = '\n'.join(['IF IA.EQ.IB THEN',
                               '    IC = 1',
                               'ELSE IF IA.GT.IB THEN',
                               '    IC = 2'])

        input_tuple = (('.EQ.', '=='), ('.GT.', '>'),)

        result_src = f2pe.replace_loop_sep(input_src, input_tuple, separator='@o@')

        expected_src = '\n'.join(['IF IA@o@==@o@IB THEN',
                                  '    IC = 1',
                                  'ELSE IF IA@o@>@o@IB THEN',
                                  '    IC = 2'])
        self.assertEqual(expected_src, result_src)


if __name__ == '__main__':
    unittest.main()
